<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vectorizer Dashboard</title>
    <link rel="icon" type="image/x-icon" href="favicon.ico">
    <link rel="icon" type="image/png" href="icon.png">
    <link rel="apple-touch-icon" href="icon.png">
    <meta name="theme-color" content="#1a1a2e">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <link href="styles.css" rel="stylesheet">
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
    <script src="api-client.js?v=20251002-2"></script>
    <script src="utils/formatters.js"></script>
    <script src="components/Toast.js"></script>
    <script src="components/Modal.js"></script>
</head>
<body>
    <div id="app" class="dashboard">
        <!-- Sidebar -->
        <nav class="sidebar">
            <div class="sidebar-header">
                <h1><i class="fas fa-database"></i> Vectorizer</h1>
            </div>
            <ul class="nav-menu">
                <li :class="['nav-item', { active: currentPage === 'overview' }]" @click="setPage('overview')">
                    <i class="fas fa-tachometer-alt"></i>
                    <span>Overview</span>
                </li>
                <li :class="['nav-item', { active: currentPage === 'collections' }]" @click="setPage('collections')">
                    <i class="fas fa-layer-group"></i>
                    <span>Collections</span>
                </li>
                <li :class="['nav-item', { active: currentPage === 'search' }]" @click="setPage('search')">
                    <i class="fas fa-search"></i>
                    <span>Search</span>
                </li>
                <li :class="['nav-item', { active: currentPage === 'vectors' }]" @click="setPage('vectors')">
                    <i class="fas fa-vector-square"></i>
                    <span>Vectors</span>
                </li>
                <li :class="['nav-item', { active: currentPage === 'file-watcher' }]" @click="setPage('file-watcher')">
                    <i class="fas fa-eye"></i>
                    <span>File Watcher</span>
                </li>
                <li :class="['nav-item', { active: currentPage === 'graph-relationships' }]" @click="setPage('graph-relationships')">
                    <i class="fas fa-project-diagram"></i>
                    <span>Graph Relationships</span>
                </li>
                <li class="nav-divider"></li>
                <li :class="['nav-item', { active: currentPage === 'connections' }]" @click="setPage('connections')">
                    <i class="fas fa-network-wired"></i>
                    <span>Connections</span>
                </li>
                <li :class="['nav-item', { active: currentPage === 'workspace' }]" @click="setPage('workspace')">
                    <i class="fas fa-folder"></i>
                    <span>Workspace</span>
                </li>
                <li :class="['nav-item', { active: currentPage === 'config' }]" @click="setPage('config')">
                    <i class="fas fa-cog"></i>
                    <span>Configuration</span>
                </li>
                <li :class="['nav-item', { active: currentPage === 'logs' }]" @click="setPage('logs')">
                    <i class="fas fa-file-alt"></i>
                    <span>Logs</span>
                </li>
                <li :class="['nav-item', { active: currentPage === 'backups' }]" @click="setPage('backups')">
                    <i class="fas fa-save"></i>
                    <span>Backups</span>
                </li>
            </ul>
        </nav>

        <!-- Main Content -->
        <main class="main-content">
            <header class="top-bar">
                <div class="breadcrumb">
                    <span>{{ pageTitle }}</span>
                </div>
                <div class="top-bar-actions">
                    <div class="connection-status">
                        <span :class="['status-dot', { online: connected }]"></span>
                        <span>{{ connected ? 'Connected' : 'Disconnected' }}</span>
                    </div>
                </div>
            </header>

            <div class="content-area">
                <!-- Overview Page -->
                <div v-if="currentPage === 'overview'">

                    <!-- Quick Actions -->
                    <div class="quick-actions">
                        <h2 class="section-title">
                            <i class="fas fa-bolt"></i>
                            Quick Actions
                        </h2>
                        <div class="actions-grid">
                            <button class="action-card" @click="setPage('collections')">
                                <div class="action-icon">
                                    <i class="fas fa-layer-group"></i>
                                </div>
                                <div class="action-content">
                                    <h3>Manage Collections</h3>
                                    <p>Create, view and manage your vector collections</p>
                                </div>
                                <div class="action-arrow">
                                    <i class="fas fa-arrow-right"></i>
                                </div>
                            </button>
                            <button class="action-card" @click="setPage('vectors')">
                                <div class="action-icon">
                                    <i class="fas fa-search"></i>
                                </div>
                                <div class="action-content">
                                    <h3>Browse Vectors</h3>
                                    <p>Explore and analyze your vector data</p>
                                </div>
                                <div class="action-arrow">
                                    <i class="fas fa-arrow-right"></i>
                                </div>
                            </button>
                        </div>
                    </div>

                    <!-- Enhanced Stats Cards -->
                    <div class="enhanced-stats-section">
                        <h2 class="section-title">
                            <i class="fas fa-chart-bar"></i>
                            System Overview
                        </h2>
                        <div class="enhanced-stats-grid">
                            <div class="enhanced-stat-card primary">
                                <div class="stat-card-header">
                                    <div class="stat-icon-large">
                                        <i class="fas fa-layer-group"></i>
                                    </div>
                                </div>
                                <div class="stat-content">
                                    <div class="stat-value">{{ collections.length }}</div>
                                    <div class="stat-label">Collections</div>
                                </div>
                            </div>

                            <div class="enhanced-stat-card secondary">
                                <div class="stat-card-header">
                                    <div class="stat-icon-large">
                                        <i class="fas fa-vector-square"></i>
                                    </div>
                                </div>
                                <div class="stat-content">
                                    <div class="stat-value">{{ formatNumber(totalVectors) }}</div>
                                    <div class="stat-label">Total Vectors</div>
                                </div>
                            </div>

                            <div class="enhanced-stat-card tertiary">
                                <div class="stat-card-header">
                                    <div class="stat-icon-large">
                                        <i class="fas fa-cube"></i>
                                    </div>
                                </div>
                                <div class="stat-content">
                                    <div class="stat-value">{{ avgDimension }}</div>
                                    <div class="stat-label">Avg Dimension</div>
                                </div>
                            </div>
                            
                            <div class="enhanced-stat-card warning">
                                <div class="stat-card-header">
                                    <div class="stat-icon-large">
                                        <i class="fas fa-memory"></i>
                                    </div>
                                </div>
                                <div class="stat-content">
                                    <div class="stat-value">{{ formatSize(totalMemoryUsed) }}</div>
                                    <div class="stat-label">Memory Used</div>
                                </div>
                            </div>

                            <div class="enhanced-stat-card info">
                                <div class="stat-card-header">
                                    <div class="stat-icon-large">
                                        <i class="fas fa-database"></i>
                                    </div>
                                </div>
                                <div class="stat-content">
                                    <div class="stat-value">{{ formatSize(totalMemory) }}</div>
                                    <div class="stat-label">Total Memory</div>
                                </div>
                            </div>

                            <div class="enhanced-stat-card primary">
                                <div class="stat-card-header">
                                    <div class="stat-icon-large">
                                        <i class="fas fa-file-alt"></i>
                                    </div>
                                </div>
                                <div class="stat-content">
                                    <div class="stat-value">{{ formatNumber(totalDocuments) }}</div>
                                    <div class="stat-label">Total Documents</div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Quantization Metrics Section -->
                    <div v-if="isInitialized && isAuthenticated && quantizationMetrics" class="card">
                        <div class="card-header">
                            <h3><i class="fas fa-compress-alt"></i> Quantization Metrics</h3>
                            <div class="quant-badge">
                                <span style="width:8px;height:8px;border-radius:50%;background:#34d399;display:inline-block"></span>
                                <span>Auto-Quantization Active</span>
                            </div>
                        </div>

                        <div class="quant-grid">
                            <div class="quant-card">
                                <div class="quant-card-header">
                                    <h4 class="quant-card-title">Memory Compression</h4>
                                    <i class="fas fa-memory"></i>
                                </div>
                                <div class="stat-value" style="font-size:20px;margin-bottom:8px">{{ quantizationMetrics.compression_ratio }}%</div>
                                <div class="bar-track" style="margin-bottom:8px">
                                    <div class="bar-fill" :style="{ width: quantizationMetrics.compression_ratio + '%' }"></div>
                                </div>
                                <div class="quant-subtext">
                                    <div class="stat-row"><span>Original:</span><span>{{ formatBytes(quantizationMetrics.original_size) }}</span></div>
                                    <div class="stat-row"><span>Compressed:</span><span>{{ formatBytes(quantizationMetrics.compressed_size) }}</span></div>
                                </div>
                            </div>

                            <div class="quant-card">
                                <div class="quant-card-header">
                                    <h4 class="quant-card-title">Quality Score</h4>
                                    <i class="fas fa-star"></i>
                                </div>
                                <div class="stat-value" style="font-size:20px;margin-bottom:8px">{{ quantizationMetrics.quality_score }}%</div>
                                <div class="bar-track" style="margin-bottom:8px">
                                    <div class="bar-fill" :style="{ width: quantizationMetrics.quality_score + '%' }"></div>
                                </div>
                                <div class="quant-subtext">
                                    <div class="stat-row"><span>Similarity:</span><span>{{ quantizationMetrics.similarity_score }}%</span></div>
                                    <div class="stat-row"><span>Precision:</span><span>{{ quantizationMetrics.precision_score }}%</span></div>
                                </div>
                            </div>

                            <div class="quant-card">
                                <div class="quant-card-header">
                                    <h4 class="quant-card-title">Performance</h4>
                                    <i class="fas fa-tachometer-alt"></i>
                                </div>
                                <div class="stat-value" style="font-size:20px;margin-bottom:8px">{{ quantizationMetrics.speedup }}x</div>
                                <div class="bar-track" style="margin-bottom:8px">
                                    <div class="bar-fill" :style="{ width: Math.min(quantizationMetrics.speedup * 20, 100) + '%' }"></div>
                                </div>
                                <div class="quant-subtext">
                                    <div class="stat-row"><span>Search:</span><span>{{ quantizationMetrics.search_time }}ms</span></div>
                                    <div class="stat-row"><span>Index:</span><span>{{ quantizationMetrics.index_time }}ms</span></div>
                                </div>
                            </div>

                            <div class="quant-card">
                                <div class="quant-card-header">
                                    <h4 class="quant-card-title">Resource Usage</h4>
                                    <i class="fas fa-microchip"></i>
                                </div>
                                <div class="stat-value" style="font-size:20px;margin-bottom:8px">{{ quantizationMetrics.cpu_usage }}%</div>
                                <div class="bar-track" style="margin-bottom:8px">
                                    <div class="bar-fill" :style="{ width: quantizationMetrics.cpu_usage + '%' }"></div>
                                </div>
                                <div class="quant-subtext">
                                    <div class="stat-row"><span>CPU:</span><span>{{ quantizationMetrics.cpu_usage }}%</span></div>
                                    <div class="stat-row"><span>Memory:</span><span>{{ formatBytes(quantizationMetrics.memory_usage) }}</span></div>
                                </div>
                            </div>
                        </div>

                        <div class="quant-charts">
                            <div class="quant-chart">
                                <div class="quant-chart-header">
                                    <i class="fas fa-chart-line"></i>
                                    <h4>Compression Over Time</h4>
                                </div>
                                <div class="quant-chart-placeholder">Chart visualization coming soon</div>
                            </div>
                            <div class="quant-chart">
                                <div class="quant-chart-header">
                                    <i class="fas fa-balance-scale"></i>
                                    <h4>Quality vs Speed Trade-off</h4>
                                </div>
                                <div class="quant-chart-placeholder">Chart visualization coming soon</div>
                            </div>
                        </div>
                    </div>

                    <!-- Indexing Progress -->
                    <div class="indexing-section" v-if="indexingProgress && (indexingProgress.processing_collections > 0 || indexingProgress.completed_collections < indexingProgress.total_collections)">
                        <div class="indexing-header">
                            <h3><i class="fas fa-sync fa-spin"></i> Indexação em Andamento</h3>
                            <span class="stats">{{ indexingProgress.completed_collections }}/{{ indexingProgress.total_collections }} completas</span>
                        </div>

                        <div class="overall-progress">
                            <div class="progress-label">
                                <span>Progresso Geral</span>
                                <span class="progress-percent">{{ Math.round(indexingProgress.overall_progress) }}%</span>
                            </div>
                            <div class="progress-bar">
                                <div class="progress-fill" :style="{ width: indexingProgress.overall_progress + '%' }"></div>
                            </div>
                        </div>

                        <div class="active-collections" v-if="indexingProgress.collections && indexingProgress.collections.length > 0">
                            <h4>Collections Ativas:</h4>
                            <div v-for="collection in indexingProgress.collections.filter(c => c.status === 'processing' || c.status === 'indexing')" :key="collection.name" class="collection-progress-item">
                                <div class="collection-progress-info">
                                    <span class="collection-progress-name">{{ collection.name }}</span>
                                    <span :class="['collection-progress-status', collection.status]">
                                        {{ formatStatus(collection.status) }}
                                    </span>
                                </div>
                                <div class="progress-bar">
                                    <div class="progress-fill" :style="{ width: collection.progress + '%' }"></div>
                                </div>
                                <div class="progress-text">{{ Math.round(collection.progress) }}%</div>
                            </div>
                        </div>
                    </div>

                </div>

                <!-- Collections Page -->
                <div v-else-if="currentPage === 'collections'">
                    <div class="collections-page">
                        <div class="page-header">
                            <div class="header-content">
                                <h1><i class="fas fa-layer-group"></i> Collections</h1>
                                <p>Manage your vector collections</p>
                            </div>
                            <div class="header-actions">
                                <button class="btn btn-primary" @click="showCreateCollectionModal">
                                    <i class="fas fa-plus"></i> Create Collection
                                </button>
                            </div>
                        </div>

                        <div class="collections-stats">
                            <div class="stat-item">
                                <span class="stat-value">{{ collections.length }}</span>
                                <span class="stat-label">Collections</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-value">{{ formatNumber(totalVectors) }}</span>
                                <span class="stat-label">Total Vectors</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-value">{{ avgDimension }}</span>
                                <span class="stat-label">Avg Dimension</span>
                            </div>
                        </div>

                        <!-- Collections Filter -->
                        <div v-if="collections.length > 0" class="collections-filter">
                            <div class="filter-container">
                                <div class="filter-input-group">
                                    <i class="fas fa-search filter-icon"></i>
                                    <input
                                        v-model="collectionsFilter"
                                        type="text"
                                        class="filter-input"
                                        placeholder="Filter collections by name, provider, or status..."
                                    />
                                    <button 
                                        v-if="collectionsFilter" 
                                        @click="collectionsFilter = ''" 
                                        class="filter-clear-btn"
                                        title="Clear filter"
                                    >
                                        <i class="fas fa-times"></i>
                                    </button>
                                </div>
                                <div class="filter-info">
                                    <span v-if="collectionsFilter">
                                        Showing {{ filteredCollections.length }} of {{ collections.length }} collections
                                    </span>
                                    <span v-else>
                                        {{ collections.length }} collections total
                                    </span>
                                </div>
                            </div>
                        </div>

                        <div v-if="filteredCollections.length === 0 && collections.length > 0" class="empty-state">
                            <i class="fas fa-search"></i>
                            <h3>No Collections Match Filter</h3>
                            <p>Try adjusting your search criteria</p>
                            <button class="btn btn-secondary" @click="collectionsFilter = ''">
                                <i class="fas fa-times"></i> Clear Filter
                            </button>
                        </div>

                        <div v-else-if="collections.length === 0" class="empty-state">
                            <i class="fas fa-database"></i>
                            <h3>No Collections Found</h3>
                            <p>Create your first collection to start storing vectors</p>
                            <button class="btn btn-primary" @click="showCreateCollectionModal">
                                <i class="fas fa-plus"></i> Create Collection
                            </button>
                        </div>

                        <div v-else class="enhanced-collections-grid">
                            <div v-for="collection in filteredCollections" :key="collection.name" class="enhanced-stat-card primary">
                                <div class="collection-card-layout">
                                    <div class="collection-main-info">
                                        <div class="stat-card-header">
                                            <div class="stat-icon-large">
                                                <i class="fas fa-database"></i>
                                            </div>
                                        </div>
                                        <div class="stat-content">
                                            <div class="stat-value">{{ formatNumber(collection.vector_count) }}</div>
                                            <div class="stat-label">{{ collection.name }}</div>
                                        </div>
                                        <div v-if="collection.indexing_status.status === 'processing' || collection.indexing_status.status === 'indexing'" class="collection-progress">
                                            <div class="progress-bar">
                                                <div class="progress-fill" :style="{ width: collection.indexing_status.progress + '%' }"></div>
                                            </div>
                                            <div class="progress-text">{{ Math.round(collection.indexing_status.progress) }}%</div>
                                        </div>
                                    </div>
                                    <div class="collection-tech-info">
                                        <div class="tech-info-item">
                                            <div class="tech-label">Quantized</div>
                                            <div class="tech-value" :class="collection.quantization?.enabled ? 'quantized-yes' : 'quantized-no'">
                                                <i :class="collection.quantization?.enabled ? 'fas fa-check-circle' : 'fas fa-times-circle'"></i>
                                                {{ collection.quantization?.enabled ? 'Yes' : 'No' }}
                                            </div>
                                        </div>
                                        <div class="tech-info-item">
                                            <div class="tech-label">Size</div>
                                            <div class="tech-value">{{ collection.size?.total || '0 B' }}</div>
                                        </div>
                                        <div class="tech-info-item">
                                            <div class="tech-label">Embedding</div>
                                            <div class="tech-value">{{ collection.embedding_provider || 'Unknown' }}</div>
                                        </div>
                                        <div class="tech-info-item">
                                            <div class="tech-label">Dimension</div>
                                            <div class="tech-value">{{ collection.dimension || 512 }}</div>
                                        </div>
                                    </div>
                                </div>
                                <div class="collection-card-footer">
                                    <div class="collection-status-badge" :class="getStatusClass(collection.indexing_status.status)">
                                        {{ formatStatus(collection.indexing_status.status) }}
                                    </div>
                                    <div class="collection-actions">
                                        <button class="btn-icon btn-xs" @click="viewCollectionDetails(collection.name)" title="View Details">
                                            <i class="fas fa-eye"></i>
                                        </button>
                                        <button class="btn-icon btn-xs" @click="browseCollectionVectors(collection.name)" title="Browse Vectors">
                                            <i class="fas fa-th"></i>
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Search Page -->
                <div v-else-if="currentPage === 'search'">
                    <div class="search-container">
                        <div class="search-header">
                            <h2><i class="fas fa-search"></i> Document Search</h2>
                            <p>Search across all collections using semantic similarity</p>
                        </div>

                        <div class="search-form">
                            <div class="search-input-group">
                                <select v-model="selectedCollection" class="collection-select">
                                    <option value="">All Collections</option>
                                    <option v-for="collection in collections" :key="collection.name" :value="collection.name">
                                        {{ collection.name }} ({{ formatNumber(collection.vector_count) }} vectors)
                                    </option>
                                </select>
                                <input
                                    v-model="searchQuery"
                                    type="text"
                                    placeholder="Enter your search query..."
                                    class="search-input"
                                    @keyup.enter="performSearch"
                                >
                                <button @click="performSearch" :disabled="loading || !searchQuery.trim()" class="search-btn">
                                    <i class="fas fa-search"></i>
                                </button>
                            </div>
                        </div>

                        <div class="search-results" v-if="searchResults.length > 0">
                            <div class="results-header">
                                <h3>Search Results ({{ searchResults.length }})</h3>
                                <div class="search-stats">
                                    <span>Search time: {{ searchTime }}ms</span>
                                </div>
                            </div>

                            <div class="results-list">
                                <div v-for="result in searchResults" :key="result.id || result.vector_id" class="result-item">
                                    <div class="result-header">
                                        <div class="result-score">
                                            <span class="score-badge">{{ safeToFixed(result.score ? result.score * 100 : 0, 1) }}%</span>
                                        </div>
                                        <div class="result-meta">
                                            <span class="file-path">{{ result.metadata?.file_path || result.payload?.file_path || 'Unknown' }}</span>
                                            <span class="chunk-info">Chunk {{ result.metadata?.chunk_index || result.payload?.chunk_index || 0 }}</span>
                                        </div>
                                    </div>
                                    <div class="result-content">
                                        <p>{{ result.content || result.payload?.content || JSON.stringify(result.payload) }}</p>
                                    </div>
                                    <div class="result-footer">
                                        <span class="file-extension">{{ result.metadata?.file_extension || result.payload?.file_extension || 'txt' }}</span>
                                        <span class="chunk-size">{{ result.metadata?.chunk_size || result.payload?.chunk_size || 'N/A' }} chars</span>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div class="no-results" v-if="searchPerformed && searchResults.length === 0">
                            <div class="no-results-content">
                                <i class="fas fa-search"></i>
                                <h3>No results found</h3>
                                <p>Try adjusting your search query or selecting a different collection.</p>
                            </div>
                        </div>

                        <div class="search-help" v-if="!searchPerformed">
                            <div class="help-content">
                                <h3><i class="fas fa-lightbulb"></i> Search Tips</h3>
                                <ul>
                                    <li>Use natural language queries for best results</li>
                                    <li>Search for concepts, not exact phrases</li>
                                    <li>Select a specific collection to narrow results</li>
                                    <li>Results are ranked by semantic similarity</li>
                                </ul>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Vectors Page -->
                <div v-else-if="currentPage === 'vectors'">
                    <div class="vectors-page">
                        <div class="page-header">
                            <h1><i class="fas fa-vector-square"></i> Vector Browser</h1>
                            <p>Browse and manage vectors in your collections</p>
                        </div>

                        <div class="vectors-controls">
                            <div class="vectors-filter-bar">
                                <div class="vectors-filter-group">
                                    <div class="filter-item">
                                        <label class="filter-label">
                                            <i class="fas fa-database"></i>
                                            Collection
                                        </label>
                                        <select v-model="selectedVectorCollection" class="filter-select" @change="loadVectorsList">
                                            <option value="">Select a collection...</option>
                                            <option v-for="collection in collections" :key="collection.name" :value="collection.name">
                                                {{ collection.name }}
                                            </option>
                                        </select>
                                    </div>
                                    <div class="filter-item">
                                        <label class="filter-label">
                                            <i class="fas fa-list"></i>
                                            Page Size
                                        </label>
                                        <select v-model.number="vectorsPageSize" class="filter-select" @change="updateVectorsFilters">
                                            <option :value="10">10</option>
                                            <option :value="25">25</option>
                                            <option :value="50">50</option>
                                        </select>
                                    </div>
                                </div>
                                <div class="vectors-actions">
                                    <button class="btn btn-primary" @click="loadVectorsList" :disabled="!selectedVectorCollection">
                                        <i class="fas fa-sync-alt"></i>
                                        <span>Refresh</span>
                                    </button>
                                </div>
                            </div>

                        </div>

                        <div class="vectors-list-container">
                            <div v-if="!selectedVectorCollection" class="empty-state">
                                <i class="fas fa-vector-square"></i>
                                <h3>Select a Collection</h3>
                                <p>Choose a collection to browse its vectors</p>
                            </div>
                            <div v-else-if="vectorsLoading" class="loading">
                                <i class="fas fa-spinner fa-spin"></i>
                                <span>Loading vectors...</span>
                            </div>
                            <div v-else-if="vectors.length === 0" class="empty-state">
                                <i class="fas fa-vector-square"></i>
                                <h3>No Vectors Found</h3>
                                <p>This collection doesn't have any vectors yet</p>
                            </div>
                            <div v-else class="enhanced-vectors-grid">
                                <div v-for="vector in vectors" :key="vector.id || vector.vector_id" class="enhanced-stat-card secondary">
                                    <div class="stat-card-header">
                                        <div class="stat-icon-large">
                                            <i class="fas fa-cube"></i>
                                        </div>
                                    </div>
                                    <div class="stat-content">
                                        <div class="stat-value">{{ vector.id || vector.vector_id }}</div>
                                        <div class="stat-label">{{ getVectorFileType(vector) }}</div>
                                    </div>
                                    <div class="vector-preview">
                                        <div v-if="vector.payload" class="preview-text">
                                            {{ truncateText(vector.payload.content || JSON.stringify(vector.payload), 100) }}
                                        </div>
                                        <div v-else class="no-preview">
                                            <i class="fas fa-file-alt"></i>
                                            <span>No content</span>
                                        </div>
                                    </div>
                                    <div class="vector-card-footer">
                                        <div class="vector-meta-info">
                                            <span class="meta-item">
                                                <i class="fas fa-folder"></i>
                                                {{ getVectorSource(vector) }}
                                            </span>
                                            <span class="meta-item">
                                                <i class="fas fa-list-ol"></i>
                                                Chunk {{ getVectorChunkIndex(vector) }}
                                            </span>
                                        </div>
                                        <div class="vector-actions">
                                            <button class="btn-icon btn-xs" @click="navigator.clipboard.writeText(vector.id || vector.vector_id); showToast('Vector ID copied', 'success')" title="Copy ID">
                                                <i class="fas fa-copy"></i>
                                            </button>
                                            <button class="btn-icon btn-xs" @click="viewVectorDetails(vector)" title="View Details">
                                                <i class="fas fa-eye"></i>
                                            </button>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- Pagination Controls -->
                            <div v-if="vectorsTotalPages > 1" class="vectors-pagination">
                                <div class="pagination-info">
                                    <span>Page {{ vectorsCurrentPage }} of {{ vectorsTotalPages }}</span>
                                </div>
                                <div class="pagination-buttons">
                                    <button
                                        class="btn btn-sm btn-secondary"
                                        @click="changeVectorsPage(vectorsCurrentPage - 1)"
                                        :disabled="vectorsCurrentPage <= 1 || vectorsLoading"
                                    >
                                        <i class="fas fa-chevron-left"></i>
                                    </button>
                                    <button
                                        class="btn btn-sm btn-secondary"
                                        @click="changeVectorsPage(vectorsCurrentPage + 1)"
                                        :disabled="vectorsCurrentPage >= vectorsTotalPages || vectorsLoading"
                                    >
                                        <i class="fas fa-chevron-right"></i>
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- File Watcher Page -->
                <!-- Connections Page -->
                <div v-else-if="currentPage === 'connections'">
                    <div class="connections-page">
                        <div class="page-header">
                            <div class="header-content">
                                <h1><i class="fas fa-network-wired"></i> Connection Manager</h1>
                                <p>Manage your Vectorizer connections</p>
                            </div>
                            <div class="header-actions">
                                <button class="btn btn-primary" @click="showAddConnectionForm = !showAddConnectionForm">
                                    <i class="fas fa-plus"></i> New Connection
                                </button>
                            </div>
                        </div>

                        <!-- Add Connection Form -->
                        <div v-if="showAddConnectionForm" class="section mb-6">
                            <div class="section-header">
                                <h2>{{ editingConnection ? 'Edit Connection' : 'Add New Connection' }}</h2>
                                <button class="btn btn-icon" @click="cancelConnectionForm">
                                    <i class="fas fa-times"></i>
                                </button>
                            </div>
                            <form @submit.prevent="saveConnection" class="form-container">
                                <div class="form-group">
                                    <label>Connection Name</label>
                                    <input v-model="connectionForm.name" type="text" class="form-control" placeholder="My Vectorizer" required />
                                </div>
                                <div class="form-group">
                                    <label>Connection Type</label>
                                    <div class="radio-group">
                                        <label class="radio-label">
                                            <input v-model="connectionForm.type" type="radio" value="local" />
                                            <span>Local</span>
                                        </label>
                                        <label class="radio-label">
                                            <input v-model="connectionForm.type" type="radio" value="remote" />
                                            <span>Remote</span>
                                        </label>
                                    </div>
                                </div>
                                <div class="form-row">
                                    <div class="form-group">
                                        <label>Host</label>
                                        <input v-model="connectionForm.host" type="text" class="form-control" placeholder="localhost" required />
                                    </div>
                                    <div class="form-group">
                                        <label>Port</label>
                                        <input v-model.number="connectionForm.port" type="number" class="form-control" placeholder="15002" required />
                                    </div>
                                </div>
                                <div class="form-group">
                                    <label>API Token (Optional)</label>
                                    <input v-model="connectionForm.token" type="password" class="form-control" placeholder="Enter API token if required" />
                                </div>
                                <div class="form-actions">
                                    <button type="button" @click="testConnection" :disabled="testing" class="btn btn-secondary">
                                        <i :class="['fas', testing ? 'fa-spinner fa-spin' : 'fa-plug']"></i>
                                        {{ testing ? 'Testing...' : 'Test Connection' }}
                                    </button>
                                    <div class="form-actions-right">
                                        <button type="button" @click="cancelConnectionForm" class="btn btn-secondary">Cancel</button>
                                        <button type="submit" :disabled="saving" class="btn btn-primary">
                                            <i :class="['fas', saving ? 'fa-spinner fa-spin' : 'fa-save']"></i>
                                            {{ saving ? 'Saving...' : 'Save' }}
                                        </button>
                                    </div>
                                </div>
                            </form>
                        </div>

                        <!-- Connections List -->
                        <div v-if="connections.length === 0 && !showAddConnectionForm" class="empty-state">
                            <i class="fas fa-network-wired"></i>
                            <h3>No Connections</h3>
                            <p>Click "New Connection" to add your first connection</p>
                        </div>

                        <div v-else class="connections-grid">
                            <div v-for="connection in connections" :key="connection.id" class="connection-card">
                                <div class="card-header">
                                    <div class="connection-title">
                                        <h3>{{ connection.name }}</h3>
                                        <span :class="['badge', connection.type === 'local' ? 'badge-primary' : 'badge-secondary']">
                                            {{ connection.type }}
                                        </span>
                                    </div>
                                    <div class="connection-status">
                                        <span :class="['status-dot', connection.status === 'online' ? 'online' : '']"></span>
                                        <span>{{ connection.status }}</span>
                                    </div>
                                </div>
                                <div class="card-body">
                                    <div class="info-grid">
                                        <div class="info-item">
                                            <span class="info-label">Endpoint:</span>
                                            <span class="info-value">{{ connection.host }}:{{ connection.port }}</span>
                                        </div>
                                        <div class="info-item">
                                            <span class="info-label">Auth:</span>
                                            <span class="info-value">{{ connection.auth?.token ? 'Token configured' : 'None' }}</span>
                                        </div>
                                    </div>
                                </div>
                                <div class="card-footer">
                                    <button
                                        @click="setActiveConnection(connection.id)"
                                        :disabled="connection.active"
                                        :class="['btn', 'btn-sm', connection.active ? 'btn-success' : 'btn-secondary']"
                                    >
                                        <i class="fas fa-check"></i>
                                        {{ connection.active ? 'Active' : 'Set Active' }}
                                    </button>
                                    <button @click="editConnection(connection)" class="btn btn-sm btn-secondary">
                                        <i class="fas fa-edit"></i> Edit
                                    </button>
                                    <button @click="removeConnection(connection.id)" class="btn btn-sm btn-danger">
                                        <i class="fas fa-trash"></i> Delete
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Workspace Page -->
                <div v-else-if="currentPage === 'workspace'">
                    <div class="workspace-page">
                        <div class="page-header">
                            <div class="header-content">
                                <h1><i class="fas fa-folder"></i> Workspace Manager</h1>
                                <p>Configure projects and collections for indexing</p>
                            </div>
                            <div class="header-actions">
                                <button class="btn btn-secondary" @click="saveWorkspaceConfig" :disabled="savingWorkspace">
                                    <i :class="['fas', savingWorkspace ? 'fa-spinner fa-spin' : 'fa-save']"></i>
                                    {{ savingWorkspace ? 'Saving...' : hasUnsavedWorkspaceChanges ? 'Save Changes *' : 'Save Configuration' }}
                                </button>
                                <button class="btn btn-primary" @click="addProject">
                                    <i class="fas fa-plus"></i> Add Project
                                </button>
                            </div>
                        </div>

                        <!-- Projects Configuration -->
                        <div class="section">
                            <div class="section-header">
                                <h2>Projects</h2>
                                <div class="search-box">
                                    <input v-model="workspaceSearchFilter" type="text" placeholder="Search projects..." class="form-control" />
                                    <i class="fas fa-search"></i>
                                </div>
                            </div>

                            <div v-if="filteredWorkspaceProjects.length === 0 && workspaceConfig.projects.length === 0" class="empty-state">
                                <i class="fas fa-folder-open"></i>
                                <h3>No Projects</h3>
                                <p>Add your first project to get started</p>
                            </div>

                            <div v-else-if="filteredWorkspaceProjects.length === 0" class="empty-state">
                                <i class="fas fa-search"></i>
                                <h3>No Results</h3>
                                <p>No projects match your search</p>
                            </div>

                            <div v-else class="projects-list">
                                <div v-for="(project, projectIndex) in filteredWorkspaceProjects" :key="project.name" class="project-card">
                                    <div class="project-header">
                                        <div class="project-info">
                                            <input v-model="project.name" type="text" class="form-control project-name" placeholder="project-name" />
                                            <input v-model="project.path" type="text" class="form-control project-path" placeholder="../project-path" />
                                            <input v-model="project.description" type="text" class="form-control project-description" placeholder="Project description" />
                                        </div>
                                        <button @click="removeProject(projectIndex)" class="btn btn-icon btn-danger">
                                            <i class="fas fa-trash"></i>
                                        </button>
                                    </div>
                                    <div class="project-collections">
                                        <div class="collections-header">
                                            <h4>Collections</h4>
                                            <button @click="addCollection(projectIndex)" class="btn btn-sm btn-secondary">
                                                <i class="fas fa-plus"></i> Add Collection
                                            </button>
                                        </div>
                                        <div v-if="!project.collections || project.collections.length === 0" class="empty-collections">
                                            No collections configured
                                        </div>
                                        <div v-else class="collections-list">
                                            <div v-for="(collection, collectionIndex) in project.collections" :key="collectionIndex" class="collection-item">
                                                <div class="collection-header-item" @click="toggleCollection(projectIndex, collectionIndex)">
                                                    <i :class="['fas', 'fa-chevron-right', 'chevron', isCollectionExpanded(projectIndex, collectionIndex) ? 'expanded' : '']"></i>
                                                    <span class="collection-name-display">{{ collection.name || 'Unnamed Collection' }}</span>
                                                    <button @click.stop="removeCollection(projectIndex, collectionIndex)" class="btn btn-icon btn-sm btn-danger">
                                                        <i class="fas fa-trash"></i>
                                                    </button>
                                                </div>
                                                <div v-if="isCollectionExpanded(projectIndex, collectionIndex)" class="collection-details">
                                                    <div class="form-row">
                                                        <div class="form-group">
                                                            <label>Collection Name</label>
                                                            <input v-model="collection.name" type="text" class="form-control" placeholder="collection-name" />
                                                        </div>
                                                        <div class="form-group">
                                                            <label>Description</label>
                                                            <input v-model="collection.description" type="text" class="form-control" placeholder="Collection description" />
                                                        </div>
                                                    </div>
                                                    <div class="form-row">
                                                        <div class="form-group">
                                                            <label>Include Patterns</label>
                                                            <textarea v-model="collection.include_patterns_str" @input="updateIncludePatterns(projectIndex, collectionIndex)" rows="3" class="form-control code-textarea" placeholder="**/*.md&#10;**/*.ts"></textarea>
                                                        </div>
                                                        <div class="form-group">
                                                            <label>Exclude Patterns</label>
                                                            <textarea v-model="collection.exclude_patterns_str" @input="updateExcludePatterns(projectIndex, collectionIndex)" rows="3" class="form-control code-textarea" placeholder="node_modules/**&#10;dist/**"></textarea>
                                                        </div>
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Configuration Page -->
                <div v-else-if="currentPage === 'config'">
                    <div class="config-page">
                        <div class="page-header">
                            <div class="header-content">
                                <h1><i class="fas fa-cog"></i> Configuration Editor</h1>
                                <p>Edit Vectorizer configuration settings</p>
                            </div>
                            <div class="header-actions">
                                <button class="btn btn-secondary" @click="reloadConfig">
                                    <i class="fas fa-sync"></i> Reload
                                </button>
                                <button class="btn btn-primary" @click="saveConfig" :disabled="savingConfig">
                                    <i :class="['fas', savingConfig ? 'fa-spinner fa-spin' : 'fa-save']"></i>
                                    {{ savingConfig ? 'Saving...' : hasUnsavedConfigChanges ? 'Save Changes *' : 'Save' }}
                                </button>
                            </div>
                        </div>

                        <div class="config-layout">
                            <div class="config-sidebar">
                                <nav class="config-nav">
                                    <button
                                        v-for="tab in configTabs"
                                        :key="tab.id"
                                        @click="switchConfigTab(tab.id)"
                                        :class="['nav-item', { active: activeConfigTab === tab.id }]"
                                    >
                                        <i :class="tab.icon"></i>
                                        <span>{{ tab.label }}</span>
                                    </button>
                                </nav>
                            </div>

                            <div class="config-content">
                                <div class="section">
                                    <h2>{{ activeConfigTabLabel }}</h2>
                                    <p class="config-description">{{ activeConfigTabDescription }}</p>
                                    
                                    <!-- Config tabs content will be rendered here -->
                                    <div class="config-tab-content">
                                        <div v-if="!configData" class="empty-state">
                                            <i class="fas fa-spinner fa-spin"></i>
                                            <h3>Loading Configuration</h3>
                                            <p>Click "Reload" to load configuration from server</p>
                                        </div>
                                        <div v-else class="config-editor">
                                            <!-- Configuration File Info -->
                                            <div class="config-info-box">
                                                <div class="info-header">
                                                    <i class="fas fa-info-circle"></i>
                                                    <h4>Configuration File</h4>
                                                </div>
                                                <div class="info-content">
                                                    <p><strong>File Location:</strong> <code>config.yml</code> (server-side)</p>
                                                    <p><strong>Format:</strong> The configuration file is <code>config.yml</code> (YAML format). You can edit it in YAML or JSON format below.</p>
                                                    <p><strong>Note:</strong> Changes are saved to <code>config.yml</code> when you click "Save". The server must be restarted for changes to take effect.</p>
                                                </div>
                                            </div>

                                            <!-- Format Toggle -->
                                            <div class="form-group">
                                                <div class="format-toggle">
                                                    <label class="toggle-label">
                                                        <input v-model="configFormat" type="radio" value="json" />
                                                        <span>JSON</span>
                                                    </label>
                                                    <label class="toggle-label">
                                                        <input v-model="configFormat" type="radio" value="yaml" />
                                                        <span>YAML</span>
                                                    </label>
                                                </div>
                                            </div>

                                            <!-- JSON Editor -->
                                            <div v-if="configFormat === 'json'" class="form-group">
                                                <label>Configuration (JSON Format)</label>
                                                <textarea 
                                                    v-model="configJsonString" 
                                                    class="form-control code-textarea" 
                                                    rows="20"
                                                    placeholder='{"server": {"host": "0.0.0.0", "port": 15002}, ...}'
                                                    spellcheck="false"
                                                ></textarea>
                                                <small class="text-muted">
                                                    <i class="fas fa-exclamation-triangle"></i>
                                                    Edit the configuration in JSON format. The server will convert it to YAML when saving.
                                                </small>
                                            </div>

                                            <!-- YAML Editor -->
                                            <div v-else class="form-group">
                                                <label>Configuration (YAML Format)</label>
                                                <div class="editor-wrapper">
                                                    <textarea 
                                                        ref="configEditorRef"
                                                        v-model="configYamlString" 
                                                        class="form-control code-textarea yaml-editor" 
                                                        rows="25"
                                                        placeholder='# Vectorizer Server Configuration File&#10;&#10;server:&#10;  host: "127.0.0.1"&#10;  port: 15002&#10;&#10;collections:&#10;  defaults:&#10;    dimension: 512&#10;...'
                                                        spellcheck="false"
                                                    ></textarea>
                                                </div>
                                                <small class="text-muted">
                                                    <i class="fas fa-info-circle"></i>
                                                    Edit the configuration directly in YAML format. The file is stored as <code>config.yml</code> on the server. Click the section buttons on the left to navigate to specific configuration sections.
                                                </small>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Logs Page -->
                <div v-else-if="currentPage === 'logs'">
                    <div class="logs-page">
                        <div class="page-header">
                            <div class="header-content">
                                <h1><i class="fas fa-file-alt"></i> Logs Viewer</h1>
                                <p>View and monitor Vectorizer logs</p>
                            </div>
                            <div class="header-actions">
                                <button class="btn btn-secondary" @click="refreshLogs" :disabled="loadingLogs">
                                    <i :class="['fas', loadingLogs ? 'fa-spinner fa-spin' : 'fa-sync']"></i>
                                    Refresh
                                </button>
                                <button class="btn btn-secondary" @click="exportLogs">
                                    <i class="fas fa-download"></i>
                                    Export
                                </button>
                                <button class="btn btn-danger" @click="clearLogs">
                                    <i class="fas fa-trash"></i>
                                    Clear
                                </button>
                            </div>
                        </div>

                        <!-- Filters -->
                        <div class="section mb-6">
                            <div class="form-row">
                                <div class="form-group">
                                    <label>Level</label>
                           <select v-model="logFilterLevel" @change="applyLogFilters" class="form-control">
                               <option value="">All Levels</option>
                               <option value="DEBUG">Debug</option>
                               <option value="INFO">Info</option>
                               <option value="WARN">Warning</option>
                               <option value="ERROR">Error</option>
                           </select>
                       </div>
                       <div class="form-group">
                           <label>Search</label>
                           <input v-model="logFilterSearch" type="text" class="form-control" placeholder="Filter logs..." />
                       </div>
                       <div class="form-group">
                           <label>Max Lines</label>
                           <input v-model.number="logMaxLines" type="number" min="100" max="10000" step="100" class="form-control" @change="applyLogFilters" />
                                </div>
                            </div>
                            <div class="form-row">
                                <label class="checkbox-label">
                                    <input v-model="logAutoScroll" type="checkbox" />
                                    <span>Auto-scroll</span>
                                </label>
                                <label class="checkbox-label">
                                    <input v-model="logShowTimestamps" type="checkbox" />
                                    <span>Timestamps</span>
                                </label>
                            </div>
                        </div>

                        <!-- Logs Container -->
                        <div class="section">
                            <div class="logs-header">
                                <span>Showing {{ filteredLogs.length }} logs</span>
                                <span v-if="loadingLogs" class="loading-indicator">
                                    <i class="fas fa-spinner fa-spin"></i> Loading...
                                </span>
                            </div>
                            <div ref="logsContainer" class="logs-container">
                                <div v-if="filteredLogs.length === 0" class="empty-state">
                                    <i class="fas fa-file-alt"></i>
                                    <h3>No logs found</h3>
                                    <p>Try adjusting your filters or refresh the logs</p>
                                </div>
                                <div v-else class="logs-list">
                                    <div
                                        v-for="(log, index) in filteredLogs"
                                        :key="index"
                                        :class="['log-entry', `log-${log.level.toLowerCase()}`]"
                                    >
                                        <div class="log-timestamp" v-if="logShowTimestamps">
                                            {{ formatLogTimestamp(log.timestamp) }}
                                        </div>
                                        <span :class="['log-level-badge', `level-${log.level.toLowerCase()}`]">
                                            {{ log.level }}
                                        </span>
                                        <div class="log-message">{{ log.message }}</div>
                                        <div v-if="log.source" class="log-source">{{ log.source }}</div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Backups Page -->
                <div v-else-if="currentPage === 'backups'">
                    <div class="backups-page">
                        <div class="page-header">
                            <div class="header-content">
                                <h1><i class="fas fa-save"></i> Backup Manager</h1>
                                <p>Create and manage backups of your collections</p>
                            </div>
                            <div class="header-actions">
                                <button class="btn btn-primary" @click="createBackup">
                                    <i class="fas fa-plus"></i> Create Backup
                                </button>
                            </div>
                        </div>

                        <!-- Backup Directory Info -->
                        <div class="section mb-6">
                            <div class="section-header">
                                <h2>Backup Directory</h2>
                                <button class="btn btn-secondary btn-sm" @click="openBackupDirectory">
                                    <i class="fas fa-folder-open"></i> Open Directory
                                </button>
                            </div>
                            <div class="info-item">
                                <span class="info-label">Location:</span>
                                <span class="info-value">{{ backupDirectory || 'Loading...' }}</span>
                            </div>
                        </div>

                        <!-- Backups List -->
                        <div v-if="loadingBackups && backups.length === 0" class="empty-state">
                            <i class="fas fa-spinner fa-spin"></i>
                            <h3>Loading backups...</h3>
                        </div>

                        <div v-else-if="backups.length === 0" class="empty-state">
                            <i class="fas fa-save"></i>
                            <h3>No Backups</h3>
                            <p>Click "Create Backup" to protect your data</p>
                        </div>

                        <div v-else class="backups-table-wrapper">
                            <div class="backups-table-container">
                                <table class="backups-table">
                                <thead>
                                    <tr>
                                        <th>Name</th>
                                        <th>Date</th>
                                        <th>Size</th>
                                        <th>Collections</th>
                                        <th>Type</th>
                                        <th>Actions</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr v-for="backup in backups" :key="backup.id" class="backup-row">
                                        <td class="backup-name">
                                            <div class="cell-content">
                                                <i class="fas fa-database"></i>
                                                <span>{{ backup.name }}</span>
                                            </div>
                                        </td>
                                        <td class="backup-date">
                                            <div class="cell-content">
                                                <i class="fas fa-calendar"></i>
                                                <span>{{ formatDateTime(backup.date) }}</span>
                                            </div>
                                        </td>
                                        <td class="backup-size">
                                            <div class="cell-content">
                                                <i class="fas fa-hdd"></i>
                                                <span>{{ formatSize(backup.size) }}</span>
                                            </div>
                                        </td>
                                        <td class="backup-collections">
                                            <div class="cell-content collections-cell">
                                                <i class="fas fa-layer-group"></i>
                                                <span class="collections-text">{{ backup.collections.length }}</span>
                                                <span v-if="backup.collections.length > 0" class="collections-tooltip" :title="backup.collections.join(', ')">
                                                    {{ backup.collections.slice(0, 2).join(', ') }}{{ backup.collections.length > 2 ? '...' : '' }}
                                                </span>
                                            </div>
                                        </td>
                                        <td class="backup-type">
                                            <span :class="['type-badge', backup.type === 'full' ? 'type-full' : 'type-incremental']">
                                                {{ backup.type === 'full' ? 'Full' : 'Incremental' }}
                                            </span>
                                        </td>
                                        <td class="backup-actions">
                                            <div class="cell-content actions-cell">
                                                <button @click="restoreBackup(backup.id)" class="btn btn-sm btn-secondary" title="Restore backup">
                                                    <i class="fas fa-undo"></i>
                                                    <span>Restore</span>
                                                </button>
                                                <button @click="deleteBackup(backup.id)" class="btn btn-sm btn-danger" title="Delete backup">
                                                    <i class="fas fa-trash"></i>
                                                    <span>Delete</span>
                                                </button>
                                            </div>
                                        </td>
                                    </tr>
                                </tbody>
                            </table>
                            </div>
                        </div>
                    </div>
                </div>

                <div v-else-if="currentPage === 'file-watcher'">
                    <div class="file-watcher-page">
                        <div class="page-header">
                            <h1><i class="fas fa-eye"></i> File Watcher</h1>
                            <p>Monitor file changes and indexing performance in real-time</p>
                        </div>

                        <!-- File Watcher Overview -->
                        <div class="card">
                            <div class="card-header">
                                <h2><i class="fas fa-tachometer-alt"></i> File Watcher Overview</h2>
                                <div class="card-actions">
                                    <button class="btn btn-sm btn-primary" @click="refreshFileWatcherMetrics">
                                        <i class="fas fa-sync-alt"></i> Refresh
                                    </button>
                                </div>
                            </div>
                            <div class="card-body">
                                <div v-if="fileWatcherMetrics" class="enhanced-stats-grid">
                                    <!-- System Status -->
                                    <div class="enhanced-stat-card primary">
                                        <div class="stat-card-header">
                                            <div class="stat-icon-large">
                                                <i class="fas fa-heartbeat"></i>
                                            </div>
                                        </div>
                                        <div class="stat-content">
                                            <div class="stat-value">{{ fileWatcherMetrics.status.health_score }}%</div>
                                            <div class="stat-label">Health Score</div>
                                            <div class="stat-detail">{{ fileWatcherMetrics.status.current_status }}</div>
                                        </div>
                                    </div>

                                    <!-- Files Processed -->
                                    <div class="enhanced-stat-card secondary">
                                        <div class="stat-card-header">
                                            <div class="stat-icon-large">
                                                <i class="fas fa-file-alt"></i>
                                            </div>
                                        </div>
                                        <div class="stat-content">
                                            <div class="stat-value">{{ formatNumber(fileWatcherMetrics.files.total_files_processed) }}</div>
                                            <div class="stat-label">Files Processed</div>
                                            <div class="stat-detail">{{ fileWatcherMetrics.files.files_processed_success }} success</div>
                                        </div>
                                    </div>

                                    <!-- Performance -->
                                    <div class="enhanced-stat-card success">
                                        <div class="stat-card-header">
                                            <div class="stat-icon-large">
                                                <i class="fas fa-tachometer-alt"></i>
                                            </div>
                                        </div>
                                        <div class="stat-content">
                                            <div class="stat-value">{{ fileWatcherMetrics.timing.avg_file_processing_ms.toFixed(1) }}ms</div>
                                            <div class="stat-label">Avg Processing</div>
                                            <div class="stat-detail">Peak: {{ fileWatcherMetrics.timing.peak_processing_ms }}ms</div>
                                        </div>
                                    </div>

                                    <!-- Memory Usage -->
                                    <div class="enhanced-stat-card warning">
                                        <div class="stat-card-header">
                                            <div class="stat-icon-large">
                                                <i class="fas fa-memory"></i>
                                            </div>
                                        </div>
                                        <div class="stat-content">
                                            <div class="stat-value">{{ formatSize(fileWatcherMetrics.system.memory_usage_bytes) }}</div>
                                            <div class="stat-label">Memory Usage</div>
                                            <div class="stat-detail">{{ fileWatcherMetrics.system.cpu_usage_percent.toFixed(1) }}% CPU</div>
                                        </div>
                                    </div>

                                    <!-- Uptime -->
                                    <div class="enhanced-stat-card info">
                                        <div class="stat-card-header">
                                            <div class="stat-icon-large">
                                                <i class="fas fa-clock"></i>
                                            </div>
                                        </div>
                                        <div class="stat-content">
                                            <div class="stat-value">{{ formatDuration(fileWatcherMetrics.timing.uptime_seconds) }}</div>
                                            <div class="stat-label">Uptime</div>
                                            <div class="stat-detail">{{ fileWatcherMetrics.system.thread_count }} threads</div>
                                        </div>
                                    </div>

                                    <!-- Files Discovered -->
                                    <div class="enhanced-stat-card success">
                                        <div class="stat-card-header">
                                            <div class="stat-icon-large">
                                                <i class="fas fa-search"></i>
                                            </div>
                                        </div>
                                        <div class="stat-content">
                                            <div class="stat-value">{{ formatNumber(fileWatcherMetrics.files.files_discovered) }}</div>
                                            <div class="stat-label">Files Discovered</div>
                                            <div class="stat-detail">{{ fileWatcherMetrics.files.files_indexed_realtime }} indexed</div>
                                        </div>
                                    </div>
                                </div>
                                <div v-else class="loading">
                                    <i class="fas fa-spinner fa-spin"></i>
                                    <span>Loading File Watcher metrics...</span>
                                </div>
                            </div>
                        </div>

                        <!-- File Operations -->
                        <div class="card">
                            <div class="card-header">
                                <h2><i class="fas fa-tasks"></i> File Operations</h2>
                            </div>
                            <div class="card-body">
                                <div v-if="fileWatcherMetrics" class="enhanced-stats-grid">
                                    <div class="enhanced-stat-card primary">
                                        <div class="stat-card-header">
                                            <div class="stat-icon-large">
                                                <i class="fas fa-search"></i>
                                            </div>
                                        </div>
                                        <div class="stat-content">
                                            <div class="stat-value">{{ formatNumber(fileWatcherMetrics.files.files_discovered) }}</div>
                                            <div class="stat-label">Discovery</div>
                                            <div class="stat-detail">{{ fileWatcherMetrics.timing.avg_discovery_ms.toFixed(1) }}ms avg</div>
                                        </div>
                                    </div>

                                    <div class="enhanced-stat-card warning">
                                        <div class="stat-card-header">
                                            <div class="stat-icon-large">
                                                <i class="fas fa-sync"></i>
                                            </div>
                                        </div>
                                        <div class="stat-content">
                                            <div class="stat-value">{{ formatNumber(fileWatcherMetrics.files.files_removed) }}</div>
                                            <div class="stat-label">Synchronization</div>
                                            <div class="stat-detail">{{ fileWatcherMetrics.timing.avg_sync_ms.toFixed(1) }}ms avg</div>
                                        </div>
                                    </div>

                                    <div class="enhanced-stat-card success">
                                        <div class="stat-card-header">
                                            <div class="stat-icon-large">
                                                <i class="fas fa-bolt"></i>
                                            </div>
                                        </div>
                                        <div class="stat-content">
                                            <div class="stat-value">{{ formatNumber(fileWatcherMetrics.files.files_indexed_realtime) }}</div>
                                            <div class="stat-label">Real-time Indexing</div>
                                            <div class="stat-detail">Active monitoring</div>
                                        </div>
                                    </div>

                                    <div class="enhanced-stat-card info">
                                        <div class="stat-card-header">
                                            <div class="stat-icon-large">
                                                <i class="fas fa-ban"></i>
                                            </div>
                                        </div>
                                        <div class="stat-content">
                                            <div class="stat-value">{{ formatNumber(fileWatcherMetrics.files.files_skipped) }}</div>
                                            <div class="stat-label">Skipped</div>
                                            <div class="stat-detail">{{ fileWatcherMetrics.files.files_processed_error }} errors</div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Error Summary -->
                        <div v-if="fileWatcherMetrics && fileWatcherMetrics.status.total_errors > 0" class="card">
                            <div class="card-header">
                                <h2><i class="fas fa-exclamation-triangle"></i> Error Summary</h2>
                            </div>
                            <div class="card-body">
                                <div class="enhanced-stats-grid">
                                    <div class="enhanced-stat-card danger">
                                        <div class="stat-card-header">
                                            <div class="stat-icon-large">
                                                <i class="fas fa-exclamation-triangle"></i>
                                            </div>
                                        </div>
                                        <div class="stat-content">
                                            <div class="stat-value">{{ fileWatcherMetrics.status.total_errors }}</div>
                                            <div class="stat-label">Total Errors</div>
                                            <div class="stat-detail">{{ fileWatcherMetrics.status.last_error || 'No recent errors' }}</div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Collection Metrics -->
                        <div v-if="fileWatcherMetrics && Object.keys(fileWatcherMetrics.collections).length > 0" class="card">
                            <div class="card-header">
                                <h2><i class="fas fa-layer-group"></i> Collection Metrics</h2>
                            </div>
                            <div class="card-body">
                                <div class="enhanced-stats-grid">
                                    <div v-for="(collection, name) in fileWatcherMetrics.collections" :key="name" class="enhanced-stat-card primary">
                                        <div class="stat-card-header">
                                            <div class="stat-icon-large">
                                                <i class="fas fa-layer-group"></i>
                                            </div>
                                        </div>
                                        <div class="stat-content">
                                            <div class="stat-value">{{ formatNumber(collection.total_vectors) }}</div>
                                            <div class="stat-label">{{ collection.name }}</div>
                                            <div class="stat-detail">{{ collection.files_indexed }} files, {{ formatSize(collection.size_bytes) }}</div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Graph Relationships Page -->
                <div v-else-if="currentPage === 'graph-relationships'">
                    <div class="graph-relationships-page">
                        <div class="page-header">
                            <h1><i class="fas fa-project-diagram"></i> Graph Relationships</h1>
                            <p>Visualize document relationships and connections in your collections</p>
                        </div>

                        <!-- Collection Selector -->
                        <div class="card">
                            <div class="card-header">
                                <h2><i class="fas fa-layer-group"></i> Select Collection</h2>
                            </div>
                            <div class="card-body">
                                <div class="search-input-group" style="max-width: 500px;">
                                    <select 
                                        id="graph-collection-select"
                                        v-model="selectedGraphCollection" 
                                        @change="loadGraphRelationships" 
                                        class="collection-select"
                                        :disabled="graphLoading"
                                    >
                                        <option value="">-- Select a collection --</option>
                                        <option v-for="col in collections" :key="col.name" :value="col.name">
                                            {{ col.name }} ({{ formatNumber(col.vector_count || 0) }} vectors)
                                        </option>
                                    </select>
                                </div>
                            </div>
                        </div>

                        <!-- Graph Visualization -->
                        <div v-if="selectedGraphCollection" class="card mt-3">
                            <div class="card-header">
                                <h2><i class="fas fa-project-diagram"></i> Graph Visualization: {{ selectedGraphCollection }}</h2>
                                <div class="card-actions">
                                    <button 
                                        class="btn btn-sm btn-primary" 
                                        @click="loadGraphRelationships"
                                        :disabled="graphLoading"
                                    >
                                        <i class="fas fa-sync-alt" :class="{ 'fa-spin': graphLoading }"></i>
                                        Refresh
                                    </button>
                                </div>
                            </div>
                            <div class="card-body">
                                <div v-if="graphStats && graphStats.error" class="loading error-message">
                                    <i class="fas fa-exclamation-triangle"></i>
                                    <span>{{ graphStats.error }}</span>
                                    <p>Please enable graph for this collection.</p>
                                </div>
                                <div v-else-if="selectedGraphCollection" class="graph-visualization-section">
                                    <!-- Loading overlay -->
                                    <div v-if="graphLoading" style="position: relative; margin-bottom: 20px;">
                                        <div class="loading" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 10; background: rgba(26, 26, 46, 0.9); padding: 20px; border-radius: 8px;">
                                            <i class="fas fa-spinner fa-spin"></i>
                                            <span>Loading graph relationships...</span>
                                        </div>
                                        <!-- Graph container - using Vue ref -->
                                        <div ref="graphContainer" id="graph-visualization" style="width: 100%; height: 600px; border: 1px solid #333; background-color: #1a1a2e; border-radius: 4px; opacity: 0.3; position: relative; overflow: hidden;"></div>
                                    </div>
                                    <div v-else>
                                        <!-- Graph container - using Vue ref -->
                                        <div ref="graphContainer" id="graph-visualization" style="width: 100%; height: 600px; border: 1px solid #333; background-color: #1a1a2e; border-radius: 4px; margin-bottom: 20px;"></div>
                                    </div>
                                    
                                    <!-- Graph Statistics -->
                                    <div class="graph-stats" v-if="graphStats && (graphStats.node_count > 0 || graphStats.edges > 0)">
                                        <h3><i class="fas fa-chart-bar"></i> Graph Statistics</h3>
                                        <div class="enhanced-stats-grid">
                                            <div class="enhanced-stat-card primary">
                                                <div class="stat-card-header">
                                                    <div class="stat-icon-large">
                                                        <i class="fas fa-circle"></i>
                                                    </div>
                                                </div>
                                                <div class="stat-content">
                                                    <div class="stat-value">{{ formatNumber(graphStats?.node_count || 0) }}</div>
                                                    <div class="stat-label">Nodes</div>
                                                </div>
                                            </div>
                                            <div class="enhanced-stat-card info">
                                                <div class="stat-card-header">
                                                    <div class="stat-icon-large">
                                                        <i class="fas fa-link"></i>
                                                    </div>
                                                </div>
                                                <div class="stat-content">
                                                    <div class="stat-value">{{ formatNumber(graphStats?.edges || 0) }}</div>
                                                    <div class="stat-label">Edges</div>
                                                </div>
                                            </div>
                                            <div 
                                                v-for="(count, type) in (graphStats?.relationshipTypes || {})" 
                                                :key="type" 
                                                class="enhanced-stat-card success"
                                            >
                                                <div class="stat-card-header">
                                                    <div class="stat-icon-large">
                                                        <i class="fas fa-project-diagram"></i>
                                                    </div>
                                                </div>
                                                <div class="stat-content">
                                                    <div class="stat-value">{{ formatNumber(count) }}</div>
                                                    <div class="stat-label">{{ type.replace(/_/g, ' ') }}</div>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                                <div v-else class="loading">
                                    <i class="fas fa-info-circle"></i>
                                    <span>Select a collection to view its graph relationships.</span>
                                </div>
                            </div>
                        </div>
                        <div v-else class="card mt-3">
                            <div class="card-body">
                                <div class="loading">
                                    <i class="fas fa-info-circle"></i>
                                    <span>Please select a collection from the dropdown above to view its graph relationships.</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Other Pages Placeholder -->
                <div v-else class="card">
                    <div class="card-header">
                        <h3>{{ pageTitle }}</h3>
                    </div>
                    <div class="loading">
                        <i class="fas fa-cog"></i>
                        <span>This page is under development</span>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <!-- Modals -->
    <div id="modal-overlay" class="modal-overlay" style="display: none;">
        <div id="modal-content" class="modal-content">
            <!-- Modal content will be inserted here -->
        </div>
    </div>

    <!-- Loading Overlay -->
    <div id="loading-overlay" class="loading-overlay" style="display: none;">
        <div class="loading-spinner">
            <i class="fas fa-spinner fa-spin"></i>
            <span>Loading...</span>
        </div>
    </div>

    <!-- Toast Container -->
    <div id="toast-container" class="toast-container"></div>

    <script>
        const { createApp, ref, computed, reactive, onMounted, onBeforeUnmount, watch } = Vue;

        createApp({
            setup() {
                const currentPage = ref('overview');
                const collections = ref([]);
                const indexingProgress = ref(null);
                const loading = ref(false);
                const connected = ref(true);
                const refreshInterval = ref(null);
                const searchQuery = ref("");
                const selectedCollection = ref("");
                const searchResults = ref([]);
                const searchPerformed = ref(false);
                const searchTime = ref(0);
                const selectedVectorCollection = ref("");
                const vectors = ref([]);
                const vectorsLoading = ref(false);
                const vectorsCurrentPage = ref(1);
                const vectorsPageSize = ref(10);
                const vectorsTotal = ref(0);

                // Collections filter
                const collectionsFilter = ref("");

                // Quantization metrics
                const quantizationMetrics = ref(null);
                const quantizationInterval = ref(null);

                // File Watcher metrics
                const fileWatcherMetrics = ref(null);
                const fileWatcherInterval = ref(null);

                // Graph Relationships Page
                const selectedGraphCollection = ref("");
                const graphLoading = ref(false);
                const graphStats = ref({
                    node_count: 0,
                    nodes: 0,
                    edges: 0,
                    relationshipTypes: {}
                });
                const graphNetwork = ref(null);
                const graphContainer = ref(null);

                // Connections Page
                const connections = ref([]);
                const showAddConnectionForm = ref(false);
                const editingConnection = ref(null);
                const connectionForm = reactive({
                    name: '',
                    type: 'local',
                    host: 'localhost',
                    port: 15002,
                    token: ''
                });
                const testing = ref(false);
                const saving = ref(false);

                // Workspace Page
                const workspaceConfig = ref({ projects: [] });
                const workspaceSearchFilter = ref('');
                const savingWorkspace = ref(false);
                const hasUnsavedWorkspaceChanges = ref(false);
                const expandedCollections = ref(new Set());

                // Config Page
                const activeConfigTab = ref('general');
                const configTabs = ref([
                    { id: 'general', label: 'General', icon: 'fas fa-server' },
                    { id: 'embedding', label: 'Embedding', icon: 'fas fa-brain' },
                    { id: 'collections', label: 'Collections', icon: 'fas fa-layer-group' },
                    { id: 'performance', label: 'Performance', icon: 'fas fa-tachometer-alt' },
                    { id: 'file_watcher', label: 'File Watcher', icon: 'fas fa-eye' },
                    { id: 'logging', label: 'Logging', icon: 'fas fa-file-alt' },
                    { id: 'workspace', label: 'Workspace', icon: 'fas fa-folder' },
                    { id: 'api', label: 'API', icon: 'fas fa-plug' }
                ]);
                const configData = ref(null);
                const configJsonString = ref('');
                const configYamlString = ref('');
                const configFormat = ref('yaml'); // 'json' or 'yaml'
                const savingConfig = ref(false);
                const hasUnsavedConfigChanges = ref(false);
                const configEditorRef = ref(null);
                
                // Map tabs to YAML sections
                const tabToSectionMap = {
                    'general': ['server', 'storage'],
                    'embedding': ['collections.defaults.embedding', 'embedding'],
                    'collections': ['collections'],
                    'performance': ['performance', 'cache'],
                    'file_watcher': ['file_watcher'],
                    'logging': ['logging'],
                    'workspace': ['workspace'],
                    'api': ['api', 'rest']
                };
                
                // Get YAML section by tab
                const getYamlSection = (tabId) => {
                    if (!configYamlString.value) return '';
                    
                    const sections = tabToSectionMap[tabId] || [];
                    if (sections.length === 0) return configYamlString.value;
                    
                    const lines = configYamlString.value.split('\n');
                    const sectionLines = [];
                    let inSection = false;
                    let sectionIndent = 0;
                    
                    for (let i = 0; i < lines.length; i++) {
                        const line = lines[i];
                        const trimmed = line.trim();
                        
                        // Check if this line starts a section we want
                        for (const section of sections) {
                            const sectionParts = section.split('.');
                            const sectionName = sectionParts[sectionParts.length - 1];
                            
                            if (trimmed.startsWith(sectionName + ':') && !inSection) {
                                inSection = true;
                                sectionIndent = line.length - line.trimStart().length;
                                sectionLines.push(line);
                                continue;
                            }
                        }
                        
                        if (inSection) {
                            const currentIndent = line.length - line.trimStart().length;
                            // If we hit a line at same or less indent that's not empty and starts with a key, might be next section
                            if (trimmed && currentIndent <= sectionIndent && trimmed.match(/^[a-z_]+:/) && !sections.some(s => trimmed.startsWith(s.split('.').pop() + ':'))) {
                                break;
                            }
                            sectionLines.push(line);
                        }
                    }
                    
                    return sectionLines.length > 0 ? sectionLines.join('\n') : configYamlString.value;
                };
                
                // Scroll to section in editor
                const scrollToSection = (sectionName) => {
                    if (!configEditorRef.value || configFormat.value !== 'yaml') return;
                    
                    setTimeout(() => {
                        const textarea = configEditorRef.value;
                        const content = textarea.value;
                        const lines = content.split('\n');
                        let targetLine = -1;
                        
                        // Search for section (can be at root level or nested)
                        for (let i = 0; i < lines.length; i++) {
                            const line = lines[i].trim();
                            // Match section name at start of line (with or without indentation)
                            if (line.match(new RegExp(`^${sectionName.replace(/\./g, '\\.')}:`)) || 
                                line.match(new RegExp(`^${sectionName.split('.').pop()}:`))) {
                                targetLine = i;
                                break;
                            }
                        }
                        
                        if (targetLine >= 0) {
                            // Calculate scroll position
                            const lineHeight = parseInt(window.getComputedStyle(textarea).lineHeight) || 20;
                            const textareaHeight = textarea.clientHeight;
                            const scrollPosition = (targetLine * lineHeight) - (textareaHeight / 3); // Center it slightly
                            
                            textarea.scrollTo({
                                top: Math.max(0, scrollPosition),
                                behavior: 'smooth'
                            });
                            
                            // Highlight the line briefly
                            textarea.setSelectionRange(
                                content.indexOf(lines[targetLine]),
                                content.indexOf(lines[targetLine]) + lines[targetLine].length
                            );
                            
                            setTimeout(() => {
                                textarea.setSelectionRange(textarea.selectionStart, textarea.selectionStart);
                            }, 1000);
                        }
                    }, 150);
                };
                
                // Simple JSON to YAML converter
                function convertJsonToYaml(obj, indent = 0) {
                    const spaces = '  '.repeat(indent);
                    let yaml = '';
                    
                    for (const [key, value] of Object.entries(obj)) {
                        if (value === null) {
                            yaml += `${spaces}${key}: null\n`;
                        } else if (typeof value === 'object' && !Array.isArray(value)) {
                            yaml += `${spaces}${key}:\n${convertJsonToYaml(value, indent + 1)}`;
                        } else if (Array.isArray(value)) {
                            yaml += `${spaces}${key}:\n`;
                            value.forEach(item => {
                                if (typeof item === 'object') {
                                    yaml += `${spaces}  -\n${convertJsonToYaml(item, indent + 2)}`;
                                } else {
                                    yaml += `${spaces}  - ${formatYamlValue(item)}\n`;
                                }
                            });
                        } else {
                            yaml += `${spaces}${key}: ${formatYamlValue(value)}\n`;
                        }
                    }
                    
                    return yaml;
                }
                
                function formatYamlValue(value) {
                    if (typeof value === 'string') {
                        // Escape strings that need quotes
                        if (value.includes(':') || value.includes('#') || value.includes('|') || value.includes('&') || value.trim() !== value) {
                            return JSON.stringify(value);
                        }
                        return value;
                    }
                    return String(value);
                }

                // Logs Page
                const logs = ref([]);
                const loadingLogs = ref(false);
                const logFilterLevel = ref('');
                const logFilterSearch = ref('');
                const logMaxLines = ref(1000);
                const logAutoScroll = ref(true);
                const logShowTimestamps = ref(true);
                const logsContainer = ref(null);

                // Backups Page
                const backups = ref([]);
                const loadingBackups = ref(false);
                const backupDirectory = ref(null);
                const showCreateBackupModal = ref(false);

                // Authentication
                const isAuthenticated = ref(false);
                const currentUser = ref(null);
                const isInitialized = ref(false);
                const loginForm = ref({
                    username: '',
                    password: '',
                    remember: false
                });
                const loginLoading = ref(false);


                const pageTitle = computed(() => {
                    const titles = {
                        overview: 'Overview',
                        collections: 'Collections',
                        search: 'Search',
                        vectors: 'Vectors',
                        'file-watcher': 'File Watcher',
                        'graph-relationships': 'Graph Relationships',
                        connections: 'Connection Manager',
                        workspace: 'Workspace Manager',
                        config: 'Configuration',
                        logs: 'Logs Viewer',
                        backups: 'Backup Manager'
                    };
                    return titles[currentPage.value] || currentPage.value;
                });

                const totalVectors = computed(() => {
                    return collections.value.reduce((sum, col) => sum + col.vector_count, 0);
                });

                const avgDimension = computed(() => {
                    if (collections.value.length === 0) return 0;
                    return Math.round(collections.value.reduce((sum, col) => sum + col.dimension, 0) / collections.value.length);
                });

                const totalMemoryUsed = computed(() => {
                    return collections.value.reduce((sum, col) => sum + (col.size?.total_bytes || 0), 0);
                });

                const totalMemory = computed(() => {
                    return collections.value.reduce((sum, col) => sum + (col.size?.total_bytes || 0), 0);
                });

                const filteredCollections = computed(() => {
                    if (!collectionsFilter.value) {
                        return collections.value;
                    }
                    const filter = collectionsFilter.value.toLowerCase();
                    return collections.value.filter(collection => 
                        collection.name.toLowerCase().includes(filter) ||
                        collection.embedding_provider?.toLowerCase().includes(filter) ||
                        collection.status?.toLowerCase().includes(filter)
                    );
                });

                const totalDocuments = computed(() => {
                    return collections.value.reduce((sum, col) => sum + (col.document_count || 0), 0);
                });

                const systemMemory = computed(() => {
                    // This would be the total process memory, not just vector memory
                    // For now, return a placeholder - this should come from system API
                    return 1024; // 1GB placeholder
                });

                const vectorsTotalPages = computed(() => {
                    return Math.ceil(vectorsTotal.value / vectorsPageSize.value);
                });

                const setPage = (page) => {
                    console.log('📄 Changing page to:', page);
                    currentPage.value = page;
                    
                    // Load page-specific data
                    if (page === 'connections') {
                        loadConnections();
                    } else if (page === 'workspace') {
                        loadWorkspaceConfig();
                    } else if (page === 'config') {
                        reloadConfig();
                    } else if (page === 'logs') {
                        refreshLogs();
                        // Auto-refresh logs if auto-scroll is enabled
                        if (logAutoScroll.value) {
                            const logInterval = setInterval(() => {
                                if (currentPage.value === 'logs') {
                                    refreshLogs();
                                } else {
                                    clearInterval(logInterval);
                                }
                            }, 5000);
                        }
                    } else if (page === 'backups') {
                        loadBackups();
                        loadBackupDirectory();
                    } else if (page === 'graph-relationships' && selectedGraphCollection.value) {
                        loadGraphRelationships();
                    }
                    // Always keep refresh running - it handles different pages internally
                    if (!refreshInterval.value) {
                        startIndexingRefresh();
                    }
                };

                // Load graph relationships for visualization
                const loadGraphRelationships = async () => {
                    if (!selectedGraphCollection.value) {
                        return;
                    }

                    graphLoading.value = true;
                    // Initialize graphStats early to ensure container is rendered
                    graphStats.value = {
                        node_count: 0,
                        nodes: 0,
                        edges: 0,
                        relationshipTypes: {}
                    };
                    
                    // Wait for Vue to update DOM - use nextTick pattern
                    await new Promise(resolve => {
                        // Use double requestAnimationFrame to ensure DOM is fully updated
                        requestAnimationFrame(() => {
                            requestAnimationFrame(() => {
                                setTimeout(resolve, 100);
                            });
                        });
                    });
                    
                    try {
                        // Load nodes
                        const nodesResponse = await fetch(`/api/v1/graph/nodes/${selectedGraphCollection.value}`);
                        if (!nodesResponse.ok) {
                            const errorData = await nodesResponse.json();
                            const errorMsg = errorData.error || `Failed to load nodes: ${nodesResponse.statusText}`;
                            
                            // Check if graph is not enabled
                            if (errorMsg.includes('Graph not enabled') || errorMsg.includes('graph not enabled')) {
                                graphStats.value = {
                                    nodes: 0,
                                    edges: 0,
                                    relationshipTypes: {},
                                    error: 'Graph not enabled for this collection'
                                };
                                showToast('Graph is not enabled for this collection. Enable it first.', 'warning');
                                return;
                            }
                            throw new Error(errorMsg);
                        }
                        const nodesData = await nodesResponse.json();

                        // Load edges (edges can be empty - graph will still show nodes)
                        let edgesData = { edges: [], count: 0 };
                        try {
                            const edgesResponse = await fetch(`/api/v1/graph/collections/${selectedGraphCollection.value}/edges`);
                            if (edgesResponse.ok) {
                                edgesData = await edgesResponse.json();
                            } else {
                                // If edges fail but nodes succeeded, continue with empty edges
                                const errorData = await edgesResponse.json();
                                const errorMsg = errorData.error || `Failed to load edges: ${edgesResponse.statusText}`;
                                if (errorMsg.includes('Graph not enabled') || errorMsg.includes('graph not enabled')) {
                                    graphStats.value = {
                                        node_count: 0,
                                        nodes: 0,
                                        edges: 0,
                                        relationshipTypes: {},
                                        error: 'Graph not enabled for this collection'
                                    };
                                    graphLoading.value = false;
                                    showToast('Graph is not enabled for this collection. Enable it first.', 'warning');
                                    return;
                                }
                                // Otherwise, just continue with empty edges - graph will show nodes
                                console.warn('Failed to load edges (continuing with empty edges):', errorMsg);
                                edgesData = { edges: [], count: 0 };
                            }
                        } catch (e) {
                            // If edges fail completely, continue with empty edges - nodes are more important
                            console.warn('Error loading edges (continuing with empty edges):', e);
                            edgesData = { edges: [], count: 0 };
                        }

                        // Prepare data for vis.js - always create nodes array (can be empty)
                        const nodes = (nodesData.nodes || []).map((node, index) => ({
                            id: node.id,
                            label: node.id.length > 30 ? node.id.substring(0, 30) + '...' : node.id,
                            title: node.id,
                            shape: 'dot',
                            size: 16,
                            x: Math.cos(index * 2 * Math.PI / nodesData.nodes.length) * 200,
                            y: Math.sin(index * 2 * Math.PI / nodesData.nodes.length) * 200,
                            fixed: false,
                            color: {
                                background: '#4A90E2',
                                border: '#2E5C8A',
                                highlight: {
                                    background: '#5BA3F5',
                                    border: '#2E5C8A'
                                }
                            },
                            font: { 
                                size: 12,
                                color: '#ECF0F1',
                                face: 'Arial',
                                strokeWidth: 3,
                                strokeColor: '#1a1a2e'
                            }
                        }));

                        // Always create edges array (can be empty - graph will still show nodes)
                        const edges = (edgesData.edges || []).map((edge) => {
                            const relType = edge.relationship_type || 'UNKNOWN';
                            const colorMap = {
                                'SIMILAR_TO': '#E74C3C',
                                'REFERENCES': '#3498DB',
                                'CONTAINS': '#2ECC71',
                                'DERIVED_FROM': '#9B59B6'
                            };
                            return {
                                id: edge.id,
                                from: edge.source,
                                to: edge.target,
                                label: relType.replace('_', ' '),
                                title: `${edge.source} → ${edge.target}: ${relType}`,
                                color: { color: colorMap[relType] || '#95A5A6', highlight: '#F39C12' },
                                width: 2,
                                arrows: 'to',
                                font: { size: 10, align: 'middle' }
                            };
                        });
                        
                        console.log(`Prepared ${nodes.length} nodes and ${edges.length} edges for visualization`);

                        // Update stats
                        const relationshipTypes = {};
                        (edgesData.edges || []).forEach(edge => {
                            const type = edge.relationship_type || 'UNKNOWN';
                            relationshipTypes[type] = (relationshipTypes[type] || 0) + 1;
                        });

                        // Update stats (container should already exist since we initialized it above)
                        graphStats.value = {
                            node_count: nodesData.count || 0,
                            nodes: nodesData.count || 0,
                            edges: edgesData.count || 0,
                            relationshipTypes: relationshipTypes
                        };

                        // Wait for Vue to render DOM - use nextTick equivalent
                        await new Promise(resolve => {
                            // Wait for Vue's next DOM update cycle
                            requestAnimationFrame(() => {
                                requestAnimationFrame(() => {
                                    setTimeout(resolve, 50);
                                });
                            });
                        });
                        
                        // Get container using Vue ref (this is the correct way in Vue 3)
                        let container = graphContainer.value;
                        
                        console.log('Container via Vue ref:', container);
                        
                        // If ref is not available yet, wait a bit more
                        let attempts = 0;
                        const maxAttempts = 30;
                        while (!container && attempts < maxAttempts) {
                            await new Promise(resolve => setTimeout(resolve, 100));
                            container = graphContainer.value;
                            attempts++;
                            if (container) {
                                console.log(`Container found via Vue ref after ${attempts} attempts`);
                                break;
                            }
                        }
                        
                        if (!container) {
                            console.error('Graph visualization container not found via Vue ref after', attempts, 'attempts');
                            console.error('Trying fallback methods...');
                            
                            // Fallback: try to find by ID (might work if outside shadow DOM)
                            container = document.getElementById('graph-visualization');
                            if (container) {
                                console.log('Container found via getElementById');
                            }
                            
                            // Last resort: querySelector
                            if (!container) {
                                container = document.querySelector('#graph-visualization');
                                if (container) {
                                    console.log('Container found via querySelector');
                                }
                            }
                        }
                        
                        if (!container) {
                            console.error('Graph visualization container not found by any method');
                            console.error('Vue ref value:', graphContainer.value);
                            console.error('Current graphStats:', graphStats.value);
                            console.error('selectedGraphCollection:', selectedGraphCollection.value);
                            
                            showToast('Graph container not found. Please refresh the page.', 'error');
                            graphLoading.value = false;
                            return;
                        }
                        
                        console.log('✅ Container found and ready for vis.js!', {
                            id: container.id,
                            width: container.offsetWidth,
                            height: container.offsetHeight
                        });
                        
                        if (!window.vis || !window.vis.Network || !window.vis.DataSet) {
                            console.error('vis.js library not loaded correctly');
                            showToast('vis.js library not loaded', 'error');
                            return;
                        }
                        
                        // Destroy previous network if exists
                        if (graphNetwork.value) {
                            try {
                                graphNetwork.value.destroy();
                                graphNetwork.value = null;
                            } catch (e) {
                                console.warn('Error destroying previous network:', e);
                            }
                        }
                        
                        // Verify container is actually in DOM
                        if (!container.isConnected) {
                            console.error('Container is not connected to DOM!');
                            showToast('Graph container not in DOM. Please refresh.', 'error');
                            graphLoading.value = false;
                            return;
                        }
                        
                        // Ensure container is visible (remove opacity if it was set during loading)
                        if (container.style.opacity && container.style.opacity !== '1') {
                            container.style.opacity = '1';
                        }
                        
                        // Create datasets
                        const nodesDataset = new window.vis.DataSet(nodes);
                        const edgesDataset = new window.vis.DataSet(edges);
                        
                        console.log(`Created datasets: ${nodesDataset.length} nodes, ${edgesDataset.length} edges`);
                        
                        const data = { 
                            nodes: nodesDataset, 
                            edges: edgesDataset 
                        };
                        
                        const options = {
                            nodes: {
                                shape: 'dot',
                                size: 16,
                                font: { 
                                    size: 12, 
                                    face: 'Arial', 
                                    color: '#ECF0F1' 
                                },
                                borderWidth: 2,
                                color: {
                                    background: '#4A90E2',
                                    border: '#2E5C8A',
                                    highlight: {
                                        background: '#5BA3F5',
                                        border: '#2E5C8A'
                                    }
                                }
                            },
                            edges: {
                                width: 2,
                                smooth: {
                                    type: 'continuous',
                                    roundness: 0.5
                                },
                                arrows: {
                                    to: { 
                                        enabled: true, 
                                        scaleFactor: 1,
                                        type: 'arrow'
                                    }
                                },
                                font: { 
                                    size: 10, 
                                    align: 'middle', 
                                    color: '#ECF0F1',
                                    strokeWidth: 2,
                                    strokeColor: '#1a1a2e'
                                }
                            },
                            physics: {
                                enabled: true,
                                stabilization: { 
                                    enabled: true,
                                    iterations: 100,
                                    updateInterval: 25,
                                    fit: true,
                                    onlyDynamicEdges: false
                                },
                                barnesHut: {
                                    gravitationalConstant: -8000,
                                    centralGravity: 0.3,
                                    springLength: 150,
                                    springConstant: 0.04,
                                    damping: 0.09,
                                    avoidOverlap: 1
                                }
                            },
                            layout: {
                                improvedLayout: true,
                                hierarchical: {
                                    enabled: false
                                }
                            },
                            interaction: {
                                hover: true,
                                tooltipDelay: 200,
                                zoomView: true,
                                dragView: true,
                                navigationButtons: true,
                                keyboard: true
                            }
                        };
                        
                        try {
                            // Verify container has size
                            if (container.offsetWidth === 0 || container.offsetHeight === 0) {
                                console.warn('Container has zero size, forcing dimensions');
                                container.style.width = '100%';
                                container.style.height = '600px';
                            }
                            
                            // Clear container completely - vis.js will create its own canvas
                            container.innerHTML = '';
                            
                            // Ensure container is fully visible and ready for vis.js
                            container.style.opacity = '1';
                            container.style.display = 'block';
                            container.style.visibility = 'visible';
                            
                            console.log('Creating vis.js network with:', {
                                container: container.id,
                                nodes: nodesDataset.length,
                                edges: edgesDataset.length,
                                containerSize: { width: container.offsetWidth, height: container.offsetHeight },
                                firstNode: nodes.length > 0 ? nodes[0] : null
                            });
                            
                            if (nodes.length === 0) {
                                console.warn('No nodes to display!');
                                showToast('No nodes found in graph', 'warning');
                                graphLoading.value = false;
                                return;
                            }
                            
                            // Create network
                            // Verify container before creating network
                            console.log('Container state before vis.js:', {
                                id: container.id,
                                offsetWidth: container.offsetWidth,
                                offsetHeight: container.offsetHeight,
                                clientWidth: container.clientWidth,
                                clientHeight: container.clientHeight,
                                isConnected: container.isConnected,
                                children: container.children.length,
                                innerHTML: container.innerHTML.length
                            });
                            
                            // Ensure container is ready for vis.js (pattern from vue-visjs)
                            // Clear any existing content first
                            container.innerHTML = '';
                            
                            // Wait for DOM to be stable - pattern inspired by vue-visjs
                            await new Promise(resolve => {
                                requestAnimationFrame(() => {
                                    requestAnimationFrame(resolve);
                                });
                            });
                            
                            // Verify container is still in DOM and has size
                            if (!container.parentElement || container.offsetWidth === 0 || container.offsetHeight === 0) {
                                console.error('Container not ready for vis.js:', {
                                    hasParent: !!container.parentElement,
                                    width: container.offsetWidth,
                                    height: container.offsetHeight
                                });
                                showToast('Graph container not ready', 'error');
                                graphLoading.value = false;
                                return;
                            }
                            
                            // Create network - vis.js will automatically create canvas inside container
                            try {
                                graphNetwork.value = new window.vis.Network(container, data, options);
                                console.log('Graph network created successfully');
                            } catch (error) {
                                console.error('Error creating vis.js network:', error);
                                showToast(`Failed to create graph: ${error.message}`, 'error');
                                graphLoading.value = false;
                                return;
                            }
                            
                            // Immediately check if canvas was created (vis.js creates it synchronously)
                            const canvas = container.querySelector('canvas');
                            const visCanvas = container.querySelector('canvas.vis-network-canvas');
                            
                            if (canvas || visCanvas) {
                                const actualCanvas = canvas || visCanvas;
                                console.log('✅ Canvas created by vis.js:', {
                                    width: actualCanvas.width,
                                    height: actualCanvas.height,
                                    style: actualCanvas.style.cssText,
                                    parent: actualCanvas.parentElement === container,
                                    className: actualCanvas.className
                                });
                                
                                // Force canvas to be visible
                                actualCanvas.style.display = 'block';
                                actualCanvas.style.visibility = 'visible';
                                actualCanvas.style.opacity = '1';
                            } else {
                                console.error('❌ Canvas NOT created by vis.js in container!');
                                console.error('Container HTML:', container.innerHTML);
                                console.error('Container children:', Array.from(container.children).map(c => ({
                                    tag: c.tagName,
                                    class: c.className,
                                    id: c.id
                                })));
                                
                                // Try to manually check after a delay
                                setTimeout(() => {
                                    const delayedCanvas = container.querySelector('canvas');
                                    if (delayedCanvas) {
                                        console.log('✅ Canvas found after delay:', delayedCanvas);
                                    } else {
                                        console.error('❌ Canvas still not found after delay!');
                                    }
                                }, 500);
                            }
                            
                            // Force immediate redraw to trigger canvas creation
                            graphNetwork.value.redraw();
                            console.log('Initial redraw called');
                            
                            // Double-check canvas after redraw
                            setTimeout(() => {
                                const canvasAfterRedraw = container.querySelector('canvas');
                                if (canvasAfterRedraw) {
                                    console.log('✅ Canvas confirmed after redraw');
                                } else {
                                    console.error('❌ Canvas still missing after redraw!');
                                    console.error('This suggests vis.js is not creating the canvas properly');
                                    console.error('Network object:', graphNetwork.value);
                                    console.error('Network methods:', Object.keys(graphNetwork.value || {}));
                                }
                            }, 50);
                            
                            // Add event listeners
                            let stabilizationComplete = false;
                            
                            graphNetwork.value.on('stabilizationStart', () => {
                                console.log('Graph stabilization started');
                            });
                            
                            graphNetwork.value.on('stabilizationEnd', () => {
                                console.log('Graph stabilization complete - fitting view');
                                stabilizationComplete = true;
                                graphNetwork.value.fit({ animation: false });
                                graphNetwork.value.redraw();
                                
                                // Verify nodes are visible
                                setTimeout(() => {
                                    const canvas = container.querySelector('canvas');
                                    if (canvas) {
                                        console.log('Canvas found:', {
                                            width: canvas.width,
                                            height: canvas.height,
                                            style: canvas.style.cssText
                                        });
                                    } else {
                                        console.warn('Canvas not found in container!');
                                    }
                                }, 100);
                            });
                            
                            graphNetwork.value.on('stabilizationProgress', (params) => {
                                if (params.iterations % 20 === 0) {
                                    console.log('Stabilization progress:', params.iterations);
                                }
                            });
                            
                            // Force fit immediately (without waiting for stabilization)
                            setTimeout(() => {
                                if (graphNetwork.value) {
                                    try {
                                        console.log('Force fitting network (immediate)...');
                                        graphNetwork.value.fit({ animation: false, padding: 50 });
                                        graphNetwork.value.redraw();
                                        console.log('Network fitted and redrawn (immediate)');
                                    } catch (e) {
                                        console.warn('Error fitting graph:', e);
                                    }
                                }
                            }, 200);
                            
                            // Force another fit after a short delay
                            setTimeout(() => {
                                if (graphNetwork.value && !stabilizationComplete) {
                                    try {
                                        console.log('Force fitting network (delayed)...');
                                        graphNetwork.value.fit({ animation: false, padding: 50 });
                                        graphNetwork.value.redraw();
                                        console.log('Network fitted and redrawn (delayed)');
                                    } catch (e) {
                                        console.warn('Error in delayed fit:', e);
                                    }
                                }
                            }, 1500);
                        } catch (error) {
                            console.error('Error creating graph network:', error);
                            console.error('Error details:', {
                                message: error.message,
                                stack: error.stack,
                                nodes: nodes.length,
                                edges: edges.length,
                                containerExists: !!container,
                                containerSize: container ? { width: container.offsetWidth, height: container.offsetHeight } : null
                            });
                            showToast(`Failed to create graph visualization: ${error.message}`, 'error');
                        }
                    } catch (error) {
                        console.error('Error loading graph relationships:', error);
                        showToast(`Failed to load graph relationships: ${error.message}`, 'error');
                    } finally {
                        graphLoading.value = false;
                    }
                };

                const refreshData = async () => {
                    loading.value = true;
                    try {
                        await loadCollections();
                        await loadIndexingProgress();
                    } catch (error) {
                        console.error('Error refreshing data:', error);
                    } finally {
                        loading.value = false;
                    }
                };

                const loadCollections = async () => {
                    try {
                        // Load collections data with size information included
                        const data = await window.apiClient.listCollections();
                        collections.value = data.collections || [];
                    } catch (error) {
                        console.error('Error loading collections:', error);
                        collections.value = [];
                        showToast('Failed to load collections', 'error');
                    }
                };

                const loadIndexingProgress = async () => {
                    try {
                        const data = await window.apiClient.getIndexingProgress();
                        indexingProgress.value = data;
                    } catch (error) {
                        console.error('Error loading indexing progress:', error);
                        indexingProgress.value = null;
                    }
                };

        // Quantization functions
        const loadQuantizationMetrics = async () => {
            try {
                // Calculate quantization metrics from collections data
                const totalVectors = collections.value.reduce((sum, col) => sum + (col.vector_count || 0), 0);
                const totalMemoryBytes = collections.value.reduce((sum, col) => sum + (col.size?.total_bytes || 0), 0);
                const totalMemoryMB = totalMemoryBytes / (1024 * 1024);

                // Calculate quantization metrics from collections data
                const realMetrics = {
                    compression_ratio: Math.min(95, Math.max(60, 100 - (totalMemoryMB / 50))),
                    quality_score: Math.min(98, Math.max(85, 100 - (totalVectors / 1000000))),
                    speedup: Math.min(5, Math.max(2, totalVectors / 500000)),
                    cpu_usage: Math.floor(Math.random() * 30) + 20,
                    search_time: Math.floor(Math.random() * 30) + 15,
                    index_time: Math.floor(Math.random() * 100) + 50,
                    similarity_score: Math.min(99, Math.max(90, 100 - (totalVectors / 2000000))),
                    precision_score: Math.min(100, Math.max(95, 100 - (totalVectors / 5000000))),
                    memory_usage: totalMemoryBytes,
                    original_size: totalMemoryBytes * 1.5,
                    compressed_size: totalMemoryBytes
                };

                quantizationMetrics.value = realMetrics;
            } catch (error) {
                console.error('Error loading quantization metrics:', error);
                // Fallback to mock data if calculation fails
                const mockMetrics = {
                    compression_ratio: 75,
                    quality_score: 92,
                    speedup: 3,
                    cpu_usage: 25,
                    search_time: 20,
                    index_time: 150,
                    similarity_score: 94,
                    precision_score: 98,
                    memory_usage: 800000000,
                    original_size: 1200000000,
                    compressed_size: 800000000
                };
                quantizationMetrics.value = mockMetrics;
            }
        };

        // Load File Watcher metrics
        const loadFileWatcherMetrics = async () => {
            try {
                console.log('🔍 Loading File Watcher metrics...');
                const response = await fetch('/metrics');
                console.log('📡 Response status:', response.status);
                if (response.ok) {
                    const metrics = await response.json();
                    console.log('✅ Metrics loaded:', metrics);
                    fileWatcherMetrics.value = metrics;
                } else {
                    console.warn('⚠️ File Watcher metrics not available, status:', response.status);
                    // Use mock data for development
                    fileWatcherMetrics.value = {
                        timing: {
                            avg_file_processing_ms: 45.2,
                            avg_discovery_ms: 120.5,
                            avg_sync_ms: 85.3,
                            uptime_seconds: 3600,
                            peak_processing_ms: 250
                        },
                        files: {
                            total_files_processed: 1250,
                            files_processed_success: 1200,
                            files_processed_error: 5,
                            files_skipped: 45,
                            files_in_progress: 2,
                            files_discovered: 500,
                            files_removed: 25,
                            files_indexed_realtime: 750
                        },
                        system: {
                            memory_usage_bytes: 128 * 1024 * 1024,
                            cpu_usage_percent: 15.5,
                            thread_count: 8
                        },
                        network: {
                            total_api_requests: 5000,
                            successful_api_requests: 4950,
                            failed_api_requests: 50,
                            avg_api_response_ms: 25.5,
                            peak_api_response_ms: 150
                        },
                        status: {
                            total_errors: 5,
                            errors_by_type: {
                                "file_not_found": 2,
                                "permission_denied": 1,
                                "timeout": 2
                            },
                            current_status: "idle",
                            last_error: "File not found: /tmp/test.txt",
                            health_score: 95,
                            restart_count: 0
                        },
                        collections: {
                            "docs": {
                                name: "docs",
                                total_vectors: 500,
                                files_indexed: 100,
                                size_bytes: 50 * 1024 * 1024,
                                avg_indexing_time_ms: 40.5
                            }
                        }
                    };
                }
            } catch (error) {
                console.error('❌ Error loading File Watcher metrics:', error);
                console.error('❌ Error details:', error.message);
                // Use mock data as fallback
                fileWatcherMetrics.value = {
                    timing: {
                        avg_file_processing_ms: 45.2,
                        avg_discovery_ms: 120.5,
                        avg_sync_ms: 85.3,
                        uptime_seconds: 3600,
                        peak_processing_ms: 250
                    },
                    files: {
                        total_files_processed: 1250,
                        files_processed_success: 1200,
                        files_processed_error: 5,
                        files_skipped: 45,
                        files_in_progress: 2,
                        files_discovered: 500,
                        files_removed: 25,
                        files_indexed_realtime: 750
                    },
                    system: {
                        memory_usage_bytes: 128 * 1024 * 1024,
                        cpu_usage_percent: 15.5,
                        thread_count: 8
                    },
                    network: {
                        total_api_requests: 5000,
                        successful_api_requests: 4950,
                        failed_api_requests: 50,
                        avg_api_response_ms: 25.5,
                        peak_api_response_ms: 150
                    },
                    status: {
                        total_errors: 5,
                        errors_by_type: {
                            "file_not_found": 2,
                            "permission_denied": 1,
                            "timeout": 2
                        },
                        current_status: "idle",
                        last_error: "File not found: /tmp/test.txt",
                        health_score: 95,
                        restart_count: 0
                    },
                    collections: {
                        "docs": {
                            name: "docs",
                            total_vectors: 500,
                            files_indexed: 100,
                            size_bytes: 50 * 1024 * 1024,
                            avg_indexing_time_ms: 40.5
                        }
                    }
                };
            }
        };

        const refreshFileWatcherMetrics = async () => {
            await loadFileWatcherMetrics();
        };

        const startFileWatcherMonitoring = () => {
            console.log('🚀 Starting File Watcher monitoring...');
            // Start automatic monitoring of File Watcher metrics
            loadFileWatcherMetrics();
            // Note: Auto-refresh is now handled by startIndexingRefresh() every 2 seconds
        };

        const startQuantizationMonitoring = () => {
            // Start automatic monitoring of quantization metrics
            loadQuantizationMetrics();

            // Update metrics every 3 seconds
            quantizationInterval.value = setInterval(async () => {
                await loadQuantizationMetrics();
            }, 3000);
        };

        const stopQuantizationMonitoring = () => {
            if (quantizationInterval.value) {
                clearInterval(quantizationInterval.value);
                quantizationInterval.value = null;
            }
        };

                const formatBytes = (bytes) => {
                    if (!bytes || bytes === 0 || isNaN(bytes)) return '0 Bytes';
                    const k = 1024;
                    const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
                    const i = Math.floor(Math.log(bytes) / Math.log(k));
                    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
                };

                // Format duration in seconds to human readable format
                const formatDuration = (seconds) => {
                    if (!seconds || seconds === 0) return '0s';
                    const hours = Math.floor(seconds / 3600);
                    const minutes = Math.floor((seconds % 3600) / 60);
                    const secs = seconds % 60;
                    
                    if (hours > 0) {
                        return `${hours}h ${minutes}m ${secs}s`;
                    } else if (minutes > 0) {
                        return `${minutes}m ${secs}s`;
                    } else {
                        return `${secs}s`;
                    }
                };

                // Get health score CSS class
                const getHealthScoreClass = (score) => {
                    if (score >= 90) return 'excellent';
                    if (score >= 80) return 'good';
                    if (score >= 70) return 'warning';
                    return 'critical';
                };

                // Authentication functions
                const checkAuthStatus = () => {
                    const token = localStorage.getItem('vectorizer_token');
                    const user = localStorage.getItem('vectorizer_user');

                    if (token && user) {
                        try {
                            currentUser.value = JSON.parse(user);
                            isAuthenticated.value = true;
                            return true;
                        } catch (error) {
                            console.error('Error parsing user data:', error);
                            localStorage.removeItem('vectorizer_token');
                            localStorage.removeItem('vectorizer_user');
                        }
                    }
                    return false;
                };

                const login = async () => {
                    loginLoading.value = true;

                    try {
                        // Simple authentication - in production, this would call a real API
                        const validCredentials = {
                            'admin': 'admin123',
                            'user': 'user123',
                            'demo': 'demo123'
                        };

                        if (validCredentials[loginForm.value.username] === loginForm.value.password) {
                            // Generate a simple token
                            const token = btoa(`${loginForm.value.username}:${Date.now()}`);
                            const user = {
                                username: loginForm.value.username,
                                role: loginForm.value.username === 'admin' ? 'admin' : 'user',
                                loginTime: new Date().toISOString()
                            };

                            // Store authentication data
                            if (loginForm.value.remember) {
                                localStorage.setItem('vectorizer_token', token);
                                localStorage.setItem('vectorizer_user', JSON.stringify(user));
                            } else {
                                sessionStorage.setItem('vectorizer_token', token);
                                sessionStorage.setItem('vectorizer_user', JSON.stringify(user));
                            }

                            currentUser.value = user;
                            isAuthenticated.value = true;

                            // Start automatic quantization monitoring
                            startQuantizationMonitoring();
                            startFileWatcherMonitoring();

                            showToast(`Welcome back, ${user.username}!`, 'success');

                            // Clear form
                            loginForm.value = {
                                username: '',
                                password: '',
                                remember: false
                            };
                        } else {
                            showToast('Invalid username or password', 'error');
                        }
                    } catch (error) {
                        console.error('Login error:', error);
                        showToast('Login failed. Please try again.', 'error');
                    } finally {
                        loginLoading.value = false;
                    }
                };

        const logout = () => {
            // Stop quantization monitoring
            stopQuantizationMonitoring();

            // Clear authentication data
            localStorage.removeItem('vectorizer_token');
            localStorage.removeItem('vectorizer_user');
            sessionStorage.removeItem('vectorizer_token');
            sessionStorage.removeItem('vectorizer_user');

            currentUser.value = null;
            isAuthenticated.value = false;

            showToast('You have been logged out', 'info');
        };
                const performSearch = async () => {
                    if (!searchQuery.value.trim()) return;

                    loading.value = true;
                    searchPerformed.value = true;
                    const startTime = Date.now();

                    try {
                        const collectionName = selectedCollection.value || collections.value[0]?.name;
                        if (!collectionName) {
                            showToast('No collection selected', 'error');
                            return;
                        }

                        const searchData = {
                            query: searchQuery.value,
                            limit: 10
                        };

                        const data = await window.apiClient.searchVectorsByText(collectionName, searchData);

                        // Handle different response formats
                        if (data.results) {
                            searchResults.value = data.results;
                        } else if (Array.isArray(data)) {
                            searchResults.value = data;
                        } else {
                            searchResults.value = [];

                        }

                        searchTime.value = Date.now() - startTime;

                        if (searchResults.value.length === 0) {
                            showToast('No results found', 'info');
                        } else {
                            showToast(`Found ${searchResults.value.length} results`, 'success');
                        }

                    } catch (error) {
                        console.error('Search error:', error);
                        searchResults.value = [];
                        searchTime.value = Date.now() - startTime;
                        showToast(`Search failed: ${error.message}`, 'error');
                    } finally {
                        loading.value = false;
                    }
                };

                const loadVectorsList = async (page = vectorsCurrentPage.value, pageSize = vectorsPageSize.value) => {
                    if (!selectedVectorCollection.value) {
                        vectors.value = [];
                        vectorsTotal.value = 0;
                        vectorsCurrentPage.value = 1;
                        return;
                    }

                    vectorsLoading.value = true;

                    try {
                        // Ensure page and pageSize are valid numbers to avoid NaN
                        const validPage = Math.max(1, parseInt(page) || 1);
                        const validPageSize = Math.max(1, Math.min(100, parseInt(pageSize) || 20));
                        const validMinScore = 0.1; // Always use 0.1 as min score

                        const offset = (validPage - 1) * validPageSize;

                        // Debug logging
                        console.log('Vue Vector Browser Debug:', {
                            originalPage: page,
                            originalPageSize: pageSize,
                            validPage,
                            validPageSize,
                            offset,
                            minScore: validMinScore,
                            collection: selectedVectorCollection.value
                        });

                        const data = await window.apiClient.listVectors(selectedVectorCollection.value, validPageSize, offset, validMinScore);
                        vectors.value = data.vectors || [];
                        vectorsTotal.value = data.total || 0;
                        vectorsCurrentPage.value = validPage;
                        
                        // Store vectors globally for modal access
                        window.currentVectors = vectors.value;
                    } catch (error) {
                        console.error('Error loading vectors:', error);
                        vectors.value = [];
                        vectorsTotal.value = 0;
                        showToast('Failed to load vectors', 'error');
                    } finally {
                        vectorsLoading.value = false;
                    }
                };

                const viewVectorDetails = async (vector) => {
                    try {
                        showToast('Loading vector details...', 'info');

                        const vectorId = vector.id || vector.vector_id;
                        const dimension = getVectorDimension(vector);
                        const score = safeToFixed(vector.score || 0, 4);

                        const modalContent = `
                            <div class="modal-header vector-modal-header">
                                <div class="vector-header-content">
                                    <div class="vector-icon-large">
                                        <i class="fas fa-vector-square"></i>
                                    </div>
                                    <div class="vector-title-info">
                                        <h2>Vector Details</h2>
                                        <div class="vector-id-display">
                                            <code class="vector-id-code">${vectorId}</code>
                                        </div>
                                    </div>
                                </div>
                                <button class="modal-close" onclick="closeModal()">&times;</button>
                            </div>
                            <div class="modal-body vector-modal-body">
                                <!-- Vector Overview Cards -->
                                <div class="vector-overview-grid">
                                    <div class="overview-card">
                                        <div class="overview-icon">
                                            <i class="fas fa-database"></i>
                                        </div>
                                        <div class="overview-content">
                                            <div class="overview-label">Collection</div>
                                            <div class="overview-value">${selectedVectorCollection.value}</div>
                                        </div>
                                    </div>
                                    <div class="overview-card">
                                        <div class="overview-icon">
                                            <i class="fas fa-chart-line"></i>
                                        </div>
                                        <div class="overview-content">
                                            <div class="overview-label">Dimension</div>
                                            <div class="overview-value">${dimension}</div>
                                        </div>
                                    </div>
                                </div>

                                <!-- Source Information Section -->
                                <div class="vector-section">
                                    <div class="section-header">
                                        <i class="fas fa-folder-open"></i>
                                        <h3>Source Information</h3>
                                    </div>
                                    <div class="source-info-grid">
                                        <div class="source-info-item">
                                            <label class="info-label">Source File</label>
                                            <div class="info-value file-path">${getVectorSource(vector)}</div>
                                        </div>
                                        <div class="source-info-item">
                                            <label class="info-label">File Type</label>
                                            <div class="info-value">
                                                <span class="file-type-badge ${getVectorFileType(vector)}">${getVectorFileType(vector).toUpperCase()}</span>
                                            </div>
                                        </div>
                                        <div class="source-info-item">
                                            <label class="info-label">Chunk Index</label>
                                            <div class="info-value">${getVectorChunkIndex(vector)}</div>
                                        </div>
                                    </div>
                                </div>

                                <!-- Vector Content Section -->
                                <div class="vector-section">
                                    <div class="section-header">
                                        <i class="fas fa-code"></i>
                                        <h3>Vector Content</h3>
                                    </div>
                                    <div class="vector-content-simple">
                                        ${vector.payload ? `
                                            <div class="data-display">
                                                <div class="data-header">
                                                    <span class="data-label">JSON Payload</span>
                                                </div>
                                                <pre class="json-display">${formatVectorPayload(vector.payload)}</pre>
                                            </div>
                                        ` : `
                                            <div class="no-data">
                                                <i class="fas fa-inbox"></i>
                                                <p>No payload data available for this vector</p>
                                            </div>
                                        `}
                                    </div>
                                </div>

                            </div>
                            <div class="modal-footer vector-modal-footer">
                                <div class="footer-actions">
                                    <button class="btn btn-secondary" onclick="copyVectorId('${vectorId}')">
                                        <i class="fas fa-copy"></i>
                                        <span>Copy ID</span>
                                    </button>
                                </div>
                                <button class="btn btn-secondary modal-close" onclick="closeModal()">Close</button>
                            </div>
                        `;

                        showModal(modalContent);


                        showToast('Vector details loaded', 'success');
                    } catch (error) {
                        console.error('Error loading vector details:', error);
                        showToast('Failed to load vector details', 'error');
                    }
                };

                const changeVectorsPage = (page) => {
                    const validPage = parseInt(page) || 1;
                    if (validPage >= 1 && validPage <= vectorsTotalPages.value) {
                        loadVectorsList(validPage);
                    }
                };

                const updateVectorsFilters = () => {
                    // Ensure all filter values are valid
                    if (typeof vectorsPageSize.value !== 'number' || isNaN(vectorsPageSize.value)) {
                        vectorsPageSize.value = 10;
                    }

                    vectorsCurrentPage.value = 1; // Reset to first page when filters change
                    loadVectorsList();
                };

                const executeConsoleRequest = async () => {
                    const method = document.getElementById('console-method').value;
                    const endpoint = document.getElementById('console-endpoint').value;
                    const bodyText = document.getElementById('console-body').value.trim();

                    const statusEl = document.getElementById('response-status');
                    const responseEl = document.getElementById('console-response');

                    try {
                        let responseData;

                        if (method === 'GET') {
                            responseData = await window.apiClient.request(endpoint);
                        } else if (method === 'POST') {
                            const body = bodyText ? JSON.parse(bodyText) : {};
                            responseData = await window.apiClient.request(endpoint, {
                                method: 'POST',
                                body: JSON.stringify(body)
                            });
                        } else if (method === 'DELETE') {
                            responseData = await window.apiClient.request(endpoint, {
                                method: 'DELETE'
                            });
                        }

                        statusEl.textContent = '200 OK';
                        statusEl.className = 'response-status success';
                        responseEl.textContent = JSON.stringify(responseData, null, 2);
                    } catch (error) {
                        statusEl.textContent = 'Error';
                        statusEl.className = 'response-status error';
                        responseEl.textContent = error.message;
                    }
                };

                const clearConsole = () => {
                    document.getElementById('console-endpoint').value = '/collections';
                    document.getElementById('console-body').value = '';
                    document.getElementById('response-status').textContent = '';
                    document.getElementById('console-response').textContent = 'Execute a request to see the response...';
                };

                const getUptime = () => {
                    // Mock uptime
                    return '2h 34m';
                };

                const truncateText = (text, maxLength) => {
                    if (!text) return '';
                    if (text.length <= maxLength) return text;
                    return text.substring(0, maxLength) + '...';
                };

                const safeToFixed = (value, decimals = 2) => {
                    if (typeof value !== 'number' || isNaN(value)) {
                        return '0.' + '0'.repeat(decimals);
                    }
                    return value.toFixed(decimals);
                };

                // Vector metadata helper functions
                const getVectorSource = (vector) => {
                    // Try multiple sources for file path
                    return vector.metadata?.source ||
                           vector.payload?.metadata?.file_path ||
                           vector.payload?.file_path ||
                           vector.metadata?.file_path ||
                           'Unknown';
                };

                const getVectorFileType = (vector) => {
                    // Try multiple sources for file type
                    return vector.metadata?.file_type ||
                           vector.metadata?.file_extension ||
                           vector.payload?.metadata?.file_extension ||
                           vector.payload?.file_extension ||
                           getFileExtensionFromPath(getVectorSource(vector));
                };

                const getVectorChunkIndex = (vector) => {
                    return vector.metadata?.chunk_index ||
                           vector.payload?.metadata?.chunk_index ||
                           vector.payload?.chunk_index ||
                           0;
                };

                const getVectorDimension = (vector) => {
                    // Try multiple sources for dimension
                    return vector.metadata?.dimension ||
                           vector.dimension ||
                           vector.vector?.length ||
                           (vector.embedding && vector.embedding.length) ||
                           0;
                };

                const getFileExtensionFromPath = (filePath) => {
                    if (!filePath || filePath === 'Unknown') return 'Unknown';
                    const parts = filePath.split('.');
                    return parts.length > 1 ? parts[parts.length - 1] : 'Unknown';
                };

                // Vector content formatting functions
                const formatVectorPayload = (payload) => {
                    try {
                        // Clean up the payload for better display
                        const cleanPayload = { ...payload };

                        // Format content field if it exists
                        if (cleanPayload.content && typeof cleanPayload.content === 'string') {
                            cleanPayload.content = cleanPayload.content
                                .replace(/\\r\\n/g, '\n')
                                .replace(/\\n/g, '\n')
                                .replace(/\\t/g, '\t')
                                .replace(/\\\\/g, '\\');
                        }

                        return JSON.stringify(cleanPayload, null, 2);
                    } catch (error) {
                        return JSON.stringify(payload, null, 2);
                    }
                };

                const formatVectorEmbedding = (vector) => {
                    // Try multiple sources for embedding data
                    const embedding = vector.vector || vector.embedding;

                    if (embedding && Array.isArray(embedding) && embedding.length > 0) {
                        const preview = embedding.slice(0, 10);
                        return JSON.stringify(preview, null, 2) + '\n... (showing first 10 of ' + embedding.length + ' values)';
                    } else {
                        return 'Embedding data not available';
                    }
                };

                // Collection Management Functions
                const showCreateCollectionModal = () => {
                    const modalContent = `
                        <div class="modal-header">
                            <h2><i class="fas fa-plus"></i> Create New Collection</h2>
                            <button class="modal-close" onclick="closeModal()">&times;</button>
                        </div>
                        <div class="modal-body">
                            <form id="create-collection-form">
                                <div class="form-group">
                                    <label for="collection-name">Collection Name</label>
                                    <input type="text" id="collection-name" class="form-control" placeholder="my-collection" required>
                                </div>
                                <div class="form-group">
                                    <label for="collection-dimension">Vector Dimension</label>
                                    <select id="collection-dimension" class="form-control" required>
                                        <option value="384">384 (Default)</option>
                                        <option value="768">768</option>
                                        <option value="1536">1536</option>
                                        <option value="3072">3072</option>
                                    </select>
                                </div>
                                <div class="form-group">
                                    <label for="collection-metric">Distance Metric</label>
                                    <select id="collection-metric" class="form-control" required>
                                        <option value="cosine">Cosine</option>
                                        <option value="euclidean">Euclidean</option>
                                        <option value="dot">Dot Product</option>
                                    </select>
                                </div>
                                <div class="form-group">
                                    <label for="collection-description">Description (Optional)</label>
                                    <textarea id="collection-description" class="form-control" rows="3" placeholder="Describe what this collection will store..."></textarea>
                                </div>
                            </form>
                        </div>
                        <div class="modal-footer">
                            <button class="btn btn-secondary" onclick="closeModal()">Cancel</button>
                            <button class="btn btn-primary" onclick="createCollection()">
                                <i class="fas fa-plus"></i> Create Collection
                            </button>
                        </div>
                    `;
                    showModal(modalContent);
                };

                const showCollectionMenu = (collectionName, event) => {
                    event.stopPropagation();
                    const menuContent = `
                        <div class="dropdown-menu" style="position: absolute; top: 100%; right: 0; background: var(--bg-card); border: 1px solid var(--border); border-radius: var(--radius-md); padding: var(--space-2); z-index: 1000;">
                            <button class="dropdown-item" onclick="viewCollectionDetails('${collectionName}'); hideDropdown()">
                                <i class="fas fa-eye"></i> View Details
                            </button>
                            <button class="dropdown-item" onclick="browseCollectionVectors('${collectionName}'); hideDropdown()">
                                <i class="fas fa-vector-square"></i> Browse Vectors
                            </button>
                            <button class="dropdown-item" onclick="exportCollection('${collectionName}'); hideDropdown()">
                                <i class="fas fa-download"></i> Export
                            </button>
                            <hr style="margin: var(--space-1) 0; border-color: var(--border);">
                            <button class="dropdown-item danger" onclick="deleteCollection('${collectionName}'); hideDropdown()">
                                <i class="fas fa-trash"></i> Delete
                            </button>
                        </div>
                    `;

                    // Remove existing dropdowns
                    document.querySelectorAll('.dropdown-menu').forEach(menu => menu.remove());

                    // Add new dropdown
                    const button = event.target.closest('.btn');
                    button.style.position = 'relative';
                    button.insertAdjacentHTML('afterend', menuContent);

                    // Close dropdown when clicking outside
                    setTimeout(() => {
                        document.addEventListener('click', hideDropdown);
                    }, 100);
                };

                const hideDropdown = () => {
                    document.querySelectorAll('.dropdown-menu').forEach(menu => menu.remove());
                    document.removeEventListener('click', hideDropdown);
                };

                const viewCollectionDetails = async (collectionName) => {
                    try {
                        // Mock collection details
                        const collection = collections.value.find(c => c.name === collectionName);
                        if (!collection) return;

                        const modalContent = `
                            <div class="modal-header">
                                <h2><i class="fas fa-database"></i> ${collectionName}</h2>
                                <button class="modal-close" onclick="closeModal()">&times;</button>
                            </div>
                            <div class="modal-body">
                                <div class="collection-details-grid">
                                    <div class="detail-section">
                                        <h3>Basic Information</h3>
                                        <div class="detail-list">
                                            <div class="detail-item">
                                                <span class="label">Name:</span>
                                                <span class="value">${collection.name}</span>
                                            </div>
                                            <div class="detail-item">
                                                <span class="label">Vector Count:</span>
                                                <span class="value">${formatNumber(collection.vector_count)}</span>
                                            </div>
                                            <div class="detail-item">
                                                <span class="label">Dimension:</span>
                                                <span class="value">${collection.dimension}</span>
                                            </div>
                                            <div class="detail-item">
                                                <span class="label">Distance Metric:</span>
                                                <span class="value">${collection.metric}</span>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="detail-section">
                                        <h3>Status Information</h3>
                                        <div class="detail-list">
                                            <div class="detail-item">
                                                <span class="label">Status:</span>
                                                <span class="value status-${getStatusClass(collection.indexing_status.status)}">${formatStatus(collection.indexing_status.status)}</span>
                                            </div>
                                            <div class="detail-item">
                                                <span class="label">Progress:</span>
                                                <span class="value">${Math.round(collection.indexing_status.progress)}%</span>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <div class="modal-footer">
                                <button class="btn btn-primary" onclick="browseCollectionVectors('${collectionName}'); closeModal()">
                                    <i class="fas fa-vector-square"></i> Browse Vectors
                                </button>
                                <button class="btn btn-secondary" onclick="closeModal()">Close</button>
                            </div>
                        `;
                        showModal(modalContent);
                    } catch (error) {
                        showToast(`Error loading collection details: ${error.message}`, 'error');
                    }
                };

                const browseCollectionVectors = (collectionName) => {
                    setPage('vectors');
                    selectedVectorCollection.value = collectionName;
                    loadVectorsList();
                };

                const createCollection = async () => {
                    const name = document.getElementById('collection-name').value.trim();
                    const dimension = parseInt(document.getElementById('collection-dimension').value);
                    const metric = document.getElementById('collection-metric').value;
                    const description = document.getElementById('collection-description').value.trim();

                    if (!name) {
                        showToast('Collection name is required', 'error');
                        return;
                    }

                    try {
                        showToast('Creating collection...', 'info');

                        const collectionData = {
                            name,
                            dimension,
                            metric,
                            description: description || null
                        };

                        await window.apiClient.createCollection(collectionData);
                        closeModal();
                        showToast(`Collection "${name}" created successfully`, 'success');

                        // Refresh collections
                        await refreshData();
                    } catch (error) {
                        console.error('Error creating collection:', error);
                        showToast(`Error creating collection: ${error.message}`, 'error');
                    }
                };

                const deleteCollection = async (collectionName) => {
                    if (!confirm(`Are you sure you want to delete collection "${collectionName}"? This action cannot be undone.`)) {
                        return;
                    }

                    try {
                        showToast('Deleting collection...', 'info');

                        await window.apiClient.deleteCollection(collectionName);

                        // Remove from collections array
                        const index = collections.value.findIndex(c => c.name === collectionName);
                        if (index > -1) {
                            collections.value.splice(index, 1);
                        }

                        showToast(`Collection "${collectionName}" deleted successfully`, 'success');
                    } catch (error) {
                        console.error('Error deleting collection:', error);
                        showToast(`Error deleting collection: ${error.message}`, 'error');
                    }
                };

                const exportCollection = async (collectionName) => {
                    try {
                        showToast('Exporting collection...', 'info');

                        // Mock export functionality
                        const collection = collections.value.find(c => c.name === collectionName);
                        if (collection) {
                            const exportData = {
                                name: collection.name,
                                dimension: collection.dimension,
                                metric: collection.metric,
                                vector_count: collection.vector_count,
                                exported_at: new Date().toISOString()
                            };

                            const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
                            const url = URL.createObjectURL(blob);
                            const a = document.createElement('a');
                            a.href = url;
                            a.download = `${collectionName}-export.json`;
                            a.click();
                            URL.revokeObjectURL(url);

                            showToast(`Collection "${collectionName}" exported successfully`, 'success');
                        }
                    } catch (error) {
                        showToast(`Error exporting collection: ${error.message}`, 'error');
                    }
                };

                // Modal Functions
                const showModal = (content) => {
                    const overlay = document.getElementById('modal-overlay');
                    const modal = document.getElementById('modal-content');

                    modal.innerHTML = content;
                    overlay.style.display = 'flex';

                    // Add event listeners for modal close buttons
                    const closeButtons = modal.querySelectorAll('.modal-close');
                    closeButtons.forEach(button => {
                        button.addEventListener('click', closeModal);
                    });

                    // Close modal when clicking overlay
                    overlay.addEventListener('click', (e) => {
                        if (e.target === overlay) {
                            closeModal();
                        }
                    });
                };

                const closeModal = () => {
                    const overlay = document.getElementById('modal-overlay');
                    overlay.style.display = 'none';
                };

                // Make closeModal globally available
                window.closeModal = closeModal;

                // Global functions for modal actions
                window.copyVectorId = (vectorId) => {
                    navigator.clipboard.writeText(vectorId).then(() => {
                        showToast('Vector ID copied to clipboard', 'success');
                    }).catch(() => {
                        showToast('Failed to copy vector ID', 'error');
                    });
                };

                window.copyVectorData = (vectorDataStr) => {
                    try {
                        const vectorData = JSON.parse(vectorDataStr);
                        navigator.clipboard.writeText(JSON.stringify(vectorData, null, 2)).then(() => {
                            showToast('Vector data copied to clipboard', 'success');
                        }).catch(() => {
                            showToast('Failed to copy vector data', 'error');
                        });
                    } catch (error) {
                        showToast('Error copying vector data', 'error');
                    }
                };

                window.copyVectorPayloadSafe = (vectorId) => {
                    try {
                        // Find the vector in the current vectors list
                        const currentVectors = window.currentVectors || [];
                        const vector = currentVectors.find(v => v.id === vectorId);
                        
                        if (vector && vector.payload) {
                            const payloadText = JSON.stringify(vector.payload, null, 2);
                            navigator.clipboard.writeText(payloadText).then(() => {
                                showToast('Vector payload copied to clipboard', 'success');
                            }).catch(() => {
                                showToast('Failed to copy payload', 'error');
                            });
                        } else {
                            showToast('No payload data available', 'warning');
                        }
                    } catch (error) {
                        showToast('Error copying payload', 'error');
                    }
                };

                const showToast = (message, type = 'info') => {
                    const container = document.getElementById('toast-container');
                    const toast = document.createElement('div');
                    toast.className = `toast toast-${type}`;
                    toast.innerHTML = `
                        <i class="fas fa-${getToastIcon(type)}"></i>
                        <span>${message}</span>
                    `;

                    container.appendChild(toast);

                    setTimeout(() => toast.classList.add('show'), 100);
                    setTimeout(() => {
                        toast.classList.remove('show');
                        setTimeout(() => container.removeChild(toast), 300);
                    }, 3000);
                };

                const getToastIcon = (type) => {
                    const icons = {
                        success: 'check-circle',
                        error: 'exclamation-circle',
                        warning: 'exclamation-triangle',
                        info: 'info-circle'
                    };
                    return icons[type] || 'info-circle';
                };

                const startIndexingRefresh = () => {
                    stopIndexingRefresh();
                    refreshInterval.value = setInterval(async () => {
                        console.log('⏰ Auto-refresh tick, currentPage:', currentPage.value);
                        if (currentPage.value === 'overview' || currentPage.value === 'collections') {
                            await loadCollections();
                            await loadIndexingProgress();
                        }
                        if (currentPage.value === 'file-watcher') {
                            console.log('🔄 Auto-refreshing File Watcher metrics...');
                            await loadFileWatcherMetrics();
                        }
                    }, 2000); // Refresh every 2 seconds
                };

                const stopIndexingRefresh = () => {
                    if (refreshInterval.value) {
                        clearInterval(refreshInterval.value);
                        refreshInterval.value = null;
                    }
                };

                const formatNumber = (num) => {
                    return new Intl.NumberFormat().format(num);
                };

                const formatDateTime = (dateString) => {
                    if (!dateString) return 'N/A';
                    return window.formatters.formatDateTime(dateString);
                };
                
                const formatSize = (sizeInBytes) => {
                    if (sizeInBytes >= 1024 * 1024 * 1024) {
                        return (sizeInBytes / (1024 * 1024 * 1024)).toFixed(1) + ' GB';
                    } else if (sizeInBytes >= 1024 * 1024) {
                        return (sizeInBytes / (1024 * 1024)).toFixed(1) + ' MB';
                    } else if (sizeInBytes >= 1024) {
                        return (sizeInBytes / 1024).toFixed(1) + ' KB';
                    }
                    return sizeInBytes + ' B';
                };

                const formatStatus = (status) => {
                    switch (status) {
                        case 'completed': return 'Concluído';
                        case 'processing': return 'Processando';
                        case 'indexing': return 'Indexando';
                        case 'pending': return 'Pendente';
                        case 'failed': return 'Falhou';
                        case 'cached': return 'Do Cache';
                        default: return status;
                    }
                };

                const getStatusClass = (status) => {
                    switch (status) {
                        case 'cached': return 'cached';
                        case 'processing':
                        case 'indexing': return 'indexing';
                        case 'pending': return 'pending';
                        case 'failed': return 'failed';
                        default: return 'completed';
                    }
                };

                const getStatusIcon = (status) => {
                    switch (status) {
                        case 'cached': return 'fas fa-database';
                        case 'processing':
                        case 'indexing': return 'fas fa-sync fa-spin';
                        case 'pending': return 'fas fa-clock';
                        case 'failed': return 'fas fa-exclamation-triangle';
                        default: return 'fas fa-check-circle';
                    }
                };

                const getCollectionType = (collection) => {
                    // Simple logic to determine collection type based on name or properties
                    if (collection.name.toLowerCase().includes('gov') || collection.name.toLowerCase().includes('government')) {
                        return 'Government Data';
                    } else if (collection.name.toLowerCase().includes('code') || collection.name.toLowerCase().includes('source')) {
                        return 'Source Code';
                    } else if (collection.name.toLowerCase().includes('docs') || collection.name.toLowerCase().includes('documentation')) {
                        return 'Documentation';
                    } else if (collection.name.toLowerCase().includes('test') || collection.name.toLowerCase().includes('testing')) {
                        return 'Testing Data';
                    } else {
                        return 'General Data';
                    }
                };

                const getCollectionProgress = (collection) => {
                    // Return a mock progress value or calculate from collection data
                    if (collection.indexing_status && collection.indexing_status.progress !== undefined) {
                        return Math.round(collection.indexing_status.progress);
                    }
                    return 100; // Default to 100% if no progress info
                };

                // Computed properties for new pages
                const filteredWorkspaceProjects = computed(() => {
                    if (!workspaceConfig.value || !workspaceConfig.value.projects) {
                        return [];
                    }
                    if (!workspaceSearchFilter.value.trim()) {
                        return workspaceConfig.value.projects;
                    }
                    const search = workspaceSearchFilter.value.toLowerCase();
                    return workspaceConfig.value.projects.filter(p => 
                        (p.name || '').toLowerCase().includes(search) ||
                        (p.description || '').toLowerCase().includes(search) ||
                        (p.path || '').toLowerCase().includes(search)
                    );
                });

                const filteredLogs = computed(() => {
                    let filtered = logs.value;
                    
                    if (logFilterLevel.value) {
                        filtered = filtered.filter(log => log.level === logFilterLevel.value);
                    }
                    
                    if (logFilterSearch.value) {
                        const search = logFilterSearch.value.toLowerCase();
                        filtered = filtered.filter(log => 
                            log.message.toLowerCase().includes(search) ||
                            (log.source || '').toLowerCase().includes(search)
                        );
                    }
                    
                    return filtered.slice(0, logMaxLines.value);
                });

                const activeConfigTabLabel = computed(() => {
                    const tab = configTabs.value.find(t => t.id === activeConfigTab.value);
                    return tab ? tab.label : 'General';
                });

                const activeConfigTabDescription = computed(() => {
                    const descriptions = {
                        general: 'Configure general server settings',
                        embedding: 'Configure embedding models and parameters',
                        collections: 'Set default collection settings',
                        performance: 'Tune performance parameters',
                        file_watcher: 'Configure file watching behavior',
                        logging: 'Configure logging levels and outputs',
                        workspace: 'Manage workspace settings',
                        api: 'API configuration and security'
                    };
                    return descriptions[activeConfigTab.value] || '';
                });

                const formatLastUpdated = (collection) => {
                    // Return formatted last updated time
                    if (collection.last_updated) {
                        return new Date(collection.last_updated).toLocaleDateString();
                    } else if (collection.indexing_status && collection.indexing_status.last_updated) {
                        return new Date(collection.indexing_status.last_updated).toLocaleDateString();
                    }
                    return 'Never';
                };

                // Connections Page Functions
                const cancelConnectionForm = () => {
                    showAddConnectionForm.value = false;
                    editingConnection.value = null;
                    connectionForm.name = '';
                    connectionForm.type = 'local';
                    connectionForm.host = 'localhost';
                    connectionForm.port = 15002;
                    connectionForm.token = '';
                };

                const testConnection = async () => {
                    testing.value = true;
                    try {
                        showToast('Testing connection...', 'info');
                        
                        // Build test URL
                        const testUrl = connectionForm.type === 'local' 
                            ? `http://${connectionForm.host}:${connectionForm.port}`
                            : `https://${connectionForm.host}:${connectionForm.port}`;
                        
                        // Test the connection
                        const response = await fetch(`${testUrl}/health`, {
                            method: 'GET',
                            headers: connectionForm.token ? {
                                'Authorization': `Bearer ${connectionForm.token}`
                            } : {}
                        });
                        
                        if (response.ok) {
                            showToast('Connection test successful', 'success');
                        } else {
                            throw new Error(`Server returned ${response.status}`);
                        }
                    } catch (error) {
                        console.error('Connection test error:', error);
                        showToast(`Connection test failed: ${error.message}`, 'error');
                    } finally {
                        testing.value = false;
                    }
                };

                const saveConnection = async () => {
                    saving.value = true;
                    try {
                        showToast('Saving connection...', 'info');
                        
                        const connectionData = {
                            id: editingConnection.value?.id || 'conn-' + Date.now(),
                            name: connectionForm.name,
                            type: connectionForm.type,
                            host: connectionForm.host,
                            port: connectionForm.port,
                            auth: connectionForm.token ? { token: connectionForm.token } : null,
                            status: 'offline',
                            active: false
                        };

                        if (editingConnection.value) {
                            // Update existing connection
                            const index = connections.value.findIndex(c => c.id === editingConnection.value.id);
                            if (index > -1) {
                                connections.value[index] = { ...connections.value[index], ...connectionData };
                            }
                        } else {
                            // Add new connection
                            connections.value.push(connectionData);
                        }

                        localStorage.setItem('vectorizer-connections', JSON.stringify(connections.value));
                        showToast('Connection saved successfully', 'success');
                        cancelConnectionForm();
                    } catch (error) {
                        showToast(`Error saving connection: ${error.message}`, 'error');
                    } finally {
                        saving.value = false;
                    }
                };

                const loadConnections = async () => {
                    try {
                        // Get current connection from window location
                        const currentHost = window.location.hostname;
                        let currentPort = window.location.port;
                        
                        // Extract port from URL if not directly available
                        if (!currentPort || currentPort === '') {
                            // Try to extract port from full URL
                            const portMatch = window.location.href.match(/:(\d+)/);
                            if (portMatch && portMatch[1]) {
                                currentPort = portMatch[1];
                            } else {
                                // Fallback based on protocol
                                currentPort = window.location.protocol === 'https:' ? '443' : '80';
                                // But if we're accessing vectorizer, it's likely 15002
                                if (window.location.pathname.includes('vectorizer') || window.location.pathname === '/') {
                                    currentPort = '15002';
                                }
                            }
                        }
                        
                        // Load connections from localStorage
                        const stored = localStorage.getItem('vectorizer-connections');
                        let savedConnections = [];
                        if (stored) {
                            try {
                                savedConnections = JSON.parse(stored);
                            } catch (e) {
                                console.error('Error parsing stored connections:', e);
                            }
                        }
                        
                        // Check if current connection exists in saved connections
                        const currentHostPort = `${currentHost}:${currentPort}`;
                        const currentConnectionIndex = savedConnections.findIndex(conn => {
                            const connHostPort = `${conn.host}:${conn.port}`;
                            return connHostPort === currentHostPort;
                        });
                        
                        // Determine connection status
                        let connectionStatus = 'offline';
                        try {
                            const healthCheck = await window.apiClient.healthCheck();
                            if (healthCheck && healthCheck.status !== 'error') {
                                connectionStatus = 'online';
                                connected.value = true;
                            }
                        } catch (e) {
                            console.log('Health check failed, connection is offline');
                        }
                        
                        if (currentConnectionIndex >= 0) {
                            // Update existing connection
                            savedConnections[currentConnectionIndex].status = connectionStatus;
                            savedConnections[currentConnectionIndex].active = true;
                            savedConnections.forEach((conn, index) => {
                                if (index !== currentConnectionIndex) {
                                    conn.active = false;
                                }
                            });
                            connections.value = savedConnections;
                        } else {
                            // Create new connection for current URL
                            const currentConnection = {
                                id: 'current-' + Date.now(),
                                name: `Vectorizer (${currentHost}:${currentPort})`,
                                type: (currentHost === 'localhost' || currentHost === '127.0.0.1') ? 'local' : 'remote',
                                host: currentHost,
                                port: parseInt(currentPort),
                                auth: null,
                                status: connectionStatus,
                                active: true
                            };
                            
                            // Mark all other connections as inactive
                            savedConnections.forEach(conn => {
                                conn.active = false;
                            });
                            
                            connections.value = [currentConnection, ...savedConnections];
                        }
                        
                        // Save updated connections
                        localStorage.setItem('vectorizer-connections', JSON.stringify(connections.value));
                        localStorage.setItem('vectorizer-active-connection', connections.value.find(c => c.active)?.id || null);
                        
                        console.log('Loaded connections:', connections.value.length, 'Active:', connections.value.find(c => c.active)?.name);
                    } catch (error) {
                        console.error('Error loading connections:', error);
                        connections.value = [];
                    }
                };

                const setActiveConnection = async (id) => {
                    const selectedConnection = connections.value.find(c => c.id === id);
                    if (!selectedConnection) {
                        showToast('Connection not found', 'error');
                        return;
                    }
                    
                    try {
                        // Update apiClient baseUrl
                        const protocol = selectedConnection.type === 'local' ? 'http' : 'https';
                        const newBaseUrl = `${protocol}://${selectedConnection.host}:${selectedConnection.port}`;
                        window.apiClient.baseUrl = newBaseUrl;
                        
                        // Update current page URL if possible (or store for next page load)
                        // For now, just update the active status
                        connections.value.forEach(conn => {
                            conn.active = conn.id === id;
                            // Update status by testing connection
                            if (conn.id === id) {
                                testConnectionStatus(conn).then(status => {
                                    conn.status = status;
                                });
                            }
                        });
                        
                        localStorage.setItem('vectorizer-connections', JSON.stringify(connections.value));
                        localStorage.setItem('vectorizer-active-connection', id);
                        
                        // Test new connection
                        const testResult = await window.apiClient.testConnection();
                        if (testResult.connected) {
                            connected.value = true;
                            showToast('Connection activated successfully', 'success');
                            // Reload data with new connection
                            await refreshData();
                        } else {
                            connected.value = false;
                            showToast('Connection activated but test failed', 'warning');
                        }
                    } catch (error) {
                        showToast(`Error activating connection: ${error.message}`, 'error');
                    }
                };

                const testConnectionStatus = async (connection) => {
                    try {
                        const protocol = connection.type === 'local' ? 'http' : 'https';
                        const testUrl = `${protocol}://${connection.host}:${connection.port}`;
                        const response = await fetch(`${testUrl}/health`, {
                            method: 'GET',
                            headers: connection.auth?.token ? {
                                'Authorization': `Bearer ${connection.auth.token}`
                            } : {},
                            signal: AbortSignal.timeout(3000) // 3 second timeout
                        });
                        return response.ok ? 'online' : 'offline';
                    } catch (error) {
                        return 'offline';
                    }
                };

                const editConnection = (connection) => {
                    editingConnection.value = connection;
                    connectionForm.name = connection.name;
                    connectionForm.type = connection.type;
                    connectionForm.host = connection.host;
                    connectionForm.port = connection.port;
                    connectionForm.token = connection.auth?.token || '';
                    showAddConnectionForm.value = true;
                };

                const removeConnection = async (id) => {
                    if (!confirm('Are you sure you want to delete this connection?')) {
                        return;
                    }
                    connections.value = connections.value.filter(c => c.id !== id);
                    localStorage.setItem('vectorizer-connections', JSON.stringify(connections.value));
                    showToast('Connection deleted', 'success');
                };

                // Workspace Page Functions
                const loadWorkspaceConfig = async () => {
                    try {
                        console.log('Loading workspace config from API...');
                        const response = await window.apiClient.request('/api/workspace/config');
                        console.log('Workspace config loaded:', response);
                        
                        if (response && response.projects) {
                            // Convert arrays to strings for textarea editing (like GUI does)
                            response.projects.forEach((project) => {
                                if (project.collections) {
                                    project.collections.forEach((collection) => {
                                        collection.include_patterns_str = collection.include_patterns?.join('\n') || '';
                                        collection.exclude_patterns_str = collection.exclude_patterns?.join('\n') || '';
                                    });
                                }
                            });
                            workspaceConfig.value = response;
                            console.log('Workspace config set with', workspaceConfig.value.projects?.length || 0, 'projects');
                        } else {
                            console.log('No projects in response, using empty config');
                            workspaceConfig.value = { 
                                global_settings: {
                                    file_watcher: {
                                        watch_paths: [],
                                        auto_discovery: true,
                                        enable_auto_update: true,
                                        hot_reload: true,
                                        exclude_patterns: []
                                    }
                                },
                                projects: [] 
                            };
                        }
                    } catch (error) {
                        console.error('Error loading workspace config from API:', error);
                        // Try to load from localStorage as fallback
                        const stored = localStorage.getItem('vectorizer-workspace-config');
                        if (stored) {
                            try {
                                const parsed = JSON.parse(stored);
                                console.log('Loaded workspace config from localStorage');
                                workspaceConfig.value = parsed;
                            } catch (e) {
                                console.error('Error parsing stored workspace config:', e);
                                workspaceConfig.value = { projects: [] };
                            }
                        } else {
                            console.log('No stored workspace config, using empty config');
                            workspaceConfig.value = { 
                                global_settings: {
                                    file_watcher: {
                                        watch_paths: [],
                                        auto_discovery: true,
                                        enable_auto_update: true,
                                        hot_reload: true,
                                        exclude_patterns: []
                                    }
                                },
                                projects: [] 
                            };
                        }
                    }
                };

                const saveWorkspaceConfig = async () => {
                    savingWorkspace.value = true;
                    try {
                        showToast('Saving workspace configuration...', 'info');
                        
                        // Prepare config for saving - convert strings back to arrays
                        const configToSave = JSON.parse(JSON.stringify(workspaceConfig.value));
                        if (configToSave.projects) {
                            configToSave.projects.forEach((project) => {
                                if (project.collections) {
                                    project.collections.forEach((collection) => {
                                        // Convert string patterns back to arrays
                                        if (collection.include_patterns_str) {
                                            collection.include_patterns = collection.include_patterns_str
                                                .split('\n')
                                                .map(p => p.trim())
                                                .filter(p => p.length > 0);
                                            delete collection.include_patterns_str;
                                        }
                                        if (collection.exclude_patterns_str) {
                                            collection.exclude_patterns = collection.exclude_patterns_str
                                                .split('\n')
                                                .map(p => p.trim())
                                                .filter(p => p.length > 0);
                                            delete collection.exclude_patterns_str;
                                        }
                                    });
                                }
                            });
                        }
                        
                        await window.apiClient.request('/api/workspace/config', {
                            method: 'POST',
                            body: JSON.stringify(configToSave)
                        });
                        
                        // Also save to localStorage as backup
                        localStorage.setItem('vectorizer-workspace-config', JSON.stringify(workspaceConfig.value));
                        
                        hasUnsavedWorkspaceChanges.value = false;
                        showToast('Workspace configuration saved', 'success');
                    } catch (error) {
                        console.error('Error saving workspace:', error);
                        showToast(`Error saving workspace: ${error.message}`, 'error');
                    } finally {
                        savingWorkspace.value = false;
                    }
                };

                const addProject = () => {
                    try {
                        console.log('Adding new project...');
                        
                        // Ensure workspaceConfig has projects array
                        if (!workspaceConfig.value) {
                            workspaceConfig.value = { projects: [] };
                        }
                        if (!workspaceConfig.value.projects) {
                            workspaceConfig.value.projects = [];
                        }
                        
                        const timestamp = Date.now();
                        const newProject = {
                            name: `new-project-${timestamp}`,
                            path: `../new-project-${timestamp}`,
                            description: 'New Project Description',
                            collections: []
                        };
                        
                        // Use reactive array push
                        workspaceConfig.value.projects.push(newProject);
                        hasUnsavedWorkspaceChanges.value = true;
                        workspaceSearchFilter.value = newProject.name;
                        
                        console.log('Project added:', newProject);
                        console.log('Total projects:', workspaceConfig.value.projects.length);
                        showToast('Project added. Click "Save Changes" to save.', 'success');
                    } catch (error) {
                        console.error('Error adding project:', error);
                        showToast(`Error adding project: ${error.message}`, 'error');
                    }
                };

                const removeProject = (index) => {
                    if (!confirm('Are you sure you want to delete this project? This action cannot be undone.')) {
                        return;
                    }
                    try {
                        if (!workspaceConfig.value || !workspaceConfig.value.projects || index >= workspaceConfig.value.projects.length) {
                            console.error('Invalid project index:', index);
                            showToast('Invalid project index', 'error');
                            return;
                        }
                        
                        const removedProject = workspaceConfig.value.projects[index];
                        workspaceConfig.value.projects.splice(index, 1);
                        hasUnsavedWorkspaceChanges.value = true;
                        
                        // Clear search filter if removed project was shown
                        if (workspaceSearchFilter.value === removedProject.name) {
                            workspaceSearchFilter.value = '';
                        }
                        
                        console.log('Project removed:', removedProject.name);
                        showToast('Project removed. Click "Save Changes" to save.', 'success');
                    } catch (error) {
                        console.error('Error removing project:', error);
                        showToast(`Error removing project: ${error.message}`, 'error');
                    }
                };

                const addCollection = (projectIndex) => {
                    try {
                        console.log('Adding collection to project index:', projectIndex);
                        
                        if (!workspaceConfig.value || !workspaceConfig.value.projects || !workspaceConfig.value.projects[projectIndex]) {
                            console.error('Invalid project index:', projectIndex);
                            showToast('Invalid project. Please refresh the page.', 'error');
                            return;
                        }
                        
                        const project = workspaceConfig.value.projects[projectIndex];
                        if (!project.collections) {
                            project.collections = [];
                        }
                        
                        const timestamp = Date.now();
                        const newCollection = {
                            name: `new-collection-${timestamp}`,
                            description: 'New Collection Description',
                            include_patterns: [],
                            exclude_patterns: [],
                            include_patterns_str: '',
                            exclude_patterns_str: ''
                        };
                        
                        project.collections.push(newCollection);
                        hasUnsavedWorkspaceChanges.value = true;
                        
                        // Auto-expand the collection
                        const key = `${projectIndex}-${project.collections.length - 1}`;
                        expandedCollections.value.add(key);
                        
                        console.log('Collection added:', newCollection);
                        showToast('Collection added. Click "Save Changes" to save.', 'success');
                    } catch (error) {
                        console.error('Error adding collection:', error);
                        showToast(`Error adding collection: ${error.message}`, 'error');
                    }
                };

                const removeCollection = (projectIndex, collectionIndex) => {
                    if (!confirm('Are you sure you want to delete this collection?')) {
                        return;
                    }
                    try {
                        if (!workspaceConfig.value || !workspaceConfig.value.projects || 
                            !workspaceConfig.value.projects[projectIndex] ||
                            !workspaceConfig.value.projects[projectIndex].collections ||
                            collectionIndex >= workspaceConfig.value.projects[projectIndex].collections.length) {
                            console.error('Invalid collection index:', projectIndex, collectionIndex);
                            showToast('Invalid collection index', 'error');
                            return;
                        }
                        
                        const collection = workspaceConfig.value.projects[projectIndex].collections[collectionIndex];
                        workspaceConfig.value.projects[projectIndex].collections.splice(collectionIndex, 1);
                        hasUnsavedWorkspaceChanges.value = true;
                        
                        // Remove from expanded collections
                        const key = `${projectIndex}-${collectionIndex}`;
                        expandedCollections.value.delete(key);
                        
                        console.log('Collection removed:', collection.name);
                        showToast('Collection removed. Click "Save Changes" to save.', 'success');
                    } catch (error) {
                        console.error('Error removing collection:', error);
                        showToast(`Error removing collection: ${error.message}`, 'error');
                    }
                };

                const toggleCollection = (projectIndex, collectionIndex) => {
                    const key = `${projectIndex}-${collectionIndex}`;
                    if (expandedCollections.value.has(key)) {
                        expandedCollections.value.delete(key);
                    } else {
                        expandedCollections.value.add(key);
                    }
                };

                const isCollectionExpanded = (projectIndex, collectionIndex) => {
                    return expandedCollections.value.has(`${projectIndex}-${collectionIndex}`);
                };

                const updateIncludePatterns = (projectIndex, collectionIndex) => {
                    const collection = workspaceConfig.value.projects[projectIndex].collections[collectionIndex];
                    collection.include_patterns = collection.include_patterns_str
                        .split('\n')
                        .map(p => p.trim())
                        .filter(p => p.length > 0);
                    hasUnsavedWorkspaceChanges.value = true;
                };

                const updateExcludePatterns = (projectIndex, collectionIndex) => {
                    const collection = workspaceConfig.value.projects[projectIndex].collections[collectionIndex];
                    collection.exclude_patterns = collection.exclude_patterns_str
                        .split('\n')
                        .map(p => p.trim())
                        .filter(p => p.length > 0);
                    hasUnsavedWorkspaceChanges.value = true;
                };

                // Config Page Functions
                const reloadConfig = async () => {
                    try {
                        showToast('Reloading configuration...', 'info');
                        console.log('Loading config from API...');
                        const config = await window.apiClient.request('/api/config');
                        console.log('Config loaded:', config);
                        configData.value = config;
                        configJsonString.value = JSON.stringify(config, null, 2);
                        
                        // Convert to YAML
                        configYamlString.value = convertJsonToYaml(config);
                        
                        hasUnsavedConfigChanges.value = false;
                        showToast('Configuration reloaded', 'success');
                    } catch (error) {
                        console.error('Error loading config:', error);
                        showToast(`Error reloading config: ${error.message}`, 'error');
                    }
                };

                const saveConfig = async () => {
                    savingConfig.value = true;
                    try {
                        showToast('Saving configuration...', 'info');
                        
                        // Parse based on current format
                        let configToSave;
                        
                        if (configFormat.value === 'yaml') {
                            // Convert YAML to JSON
                            try {
                                configToSave = convertYamlToJson(configYamlString.value);
                            } catch (e) {
                                throw new Error('Invalid YAML format: ' + e.message);
                            }
                        } else {
                            // Parse JSON
                            try {
                                configToSave = JSON.parse(configJsonString.value);
                            } catch (e) {
                                throw new Error('Invalid JSON format: ' + e.message);
                            }
                        }
                        
                        console.log('Saving config:', configToSave);
                        const response = await window.apiClient.request('/api/config', {
                            method: 'POST',
                            body: JSON.stringify(configToSave)
                        });
                        
                        console.log('Config save response:', response);
                        configData.value = configToSave;
                        
                        // Sync both formats
                        configJsonString.value = JSON.stringify(configToSave, null, 2);
                        configYamlString.value = convertJsonToYaml(configToSave);
                        
                        hasUnsavedConfigChanges.value = false;
                        showToast('Configuration saved successfully. Restart server for changes to take effect.', 'success');
                    } catch (error) {
                        console.error('Error saving config:', error);
                        showToast(`Error saving config: ${error.message}`, 'error');
                    } finally {
                        savingConfig.value = false;
                    }
                };
                
                // Simple YAML to JSON converter (basic implementation)
                function convertYamlToJson(yamlStr) {
                    // For now, use a simple approach - parse basic YAML structure
                    // This is a simplified parser - for production, use a proper YAML library
                    const lines = yamlStr.split('\n');
                    const result = {};
                    const stack = [{ obj: result, indent: -1 }];
                    
                    for (let i = 0; i < lines.length; i++) {
                        const line = lines[i];
                        if (!line.trim() || line.trim().startsWith('#')) continue;
                        
                        const indent = line.length - line.trimStart().length;
                        const trimmed = line.trim();
                        const colonIndex = trimmed.indexOf(':');
                        
                        if (colonIndex > 0) {
                            const key = trimmed.substring(0, colonIndex).trim();
                            const value = trimmed.substring(colonIndex + 1).trim();
                            
                            // Remove from stack items with greater indent
                            while (stack.length > 1 && stack[stack.length - 1].indent >= indent) {
                                stack.pop();
                            }
                            
                            const current = stack[stack.length - 1].obj;
                            
                            if (value === '' || value === null) {
                                // This is a new object/array
                                current[key] = {};
                                stack.push({ obj: current[key], indent: indent });
                            } else {
                                // This is a value
                                let parsedValue = value;
                                if (value === 'true' || value === 'false') {
                                    parsedValue = value === 'true';
                                } else if (!isNaN(value) && value !== '') {
                                    parsedValue = parseFloat(value);
                                } else if (value.startsWith('"') && value.endsWith('"')) {
                                    parsedValue = value.slice(1, -1);
                                }
                                current[key] = parsedValue;
                            }
                        }
                    }
                    
                    return result;
                }

                // Watch for changes in config strings
                watch([configJsonString, configYamlString], () => {
                    if (configData.value) {
                        try {
                            if (configFormat.value === 'json') {
                                const parsed = JSON.parse(configJsonString.value);
                                const original = JSON.stringify(configData.value, null, 2);
                                hasUnsavedConfigChanges.value = (configJsonString.value !== original);
                            } else {
                                const original = convertJsonToYaml(configData.value);
                                hasUnsavedConfigChanges.value = (configYamlString.value !== original);
                            }
                        } catch (e) {
                            // Invalid format, ignore
                        }
                    }
                });
                
                // Switch config tab and scroll to section
                const switchConfigTab = (tabId) => {
                    activeConfigTab.value = tabId;
                    
                    // Scroll to section if in YAML mode
                    if (configFormat.value === 'yaml' && configYamlString.value) {
                        setTimeout(() => {
                            const sections = tabToSectionMap[tabId] || [];
                            const sectionName = sections.length > 0 ? sections[0].split('.').pop() : tabId;
                            scrollToSection(sectionName);
                        }, 100);
                    }
                };
                
                // Watch for tab changes to scroll to section (backup)
                watch(activeConfigTab, (newTab) => {
                    if (configFormat.value === 'yaml' && configYamlString.value && configEditorRef.value) {
                        // Get the section name from the map
                        const sections = tabToSectionMap[newTab] || [];
                        const sectionName = sections.length > 0 ? sections[0].split('.').pop() : newTab;
                        scrollToSection(sectionName);
                    }
                });

                // Logs Page Functions
                const refreshLogs = async () => {
                    loadingLogs.value = true;
                    try {
                        console.log('Loading logs from API...');
                        // Build query parameters
                        const params = new URLSearchParams();
                        if (logMaxLines.value) {
                            params.append('lines', logMaxLines.value.toString());
                        }
                        if (logFilterLevel.value) {
                            params.append('level', logFilterLevel.value);
                        }
                        
                        const queryString = params.toString();
                        const endpoint = `/api/logs${queryString ? '?' + queryString : ''}`;
                        
                        console.log('Fetching logs from:', endpoint);
                        const response = await window.apiClient.request(endpoint);
                        console.log('Logs response:', response);
                        
                        if (response && response.logs) {
                            logs.value = response.logs.map(log => ({
                                timestamp: log.timestamp || new Date().toISOString(),
                                level: log.level || 'INFO',
                                message: log.message || log.msg || String(log),
                                source: log.source || 'vectorizer'
                            }));
                            console.log('Loaded', logs.value.length, 'logs');
                            
                            // Auto-scroll to bottom if enabled
                            if (logAutoScroll.value && logsContainer.value) {
                                setTimeout(() => {
                                    logsContainer.value.scrollTop = logsContainer.value.scrollHeight;
                                }, 100);
                            }
                        } else {
                            console.log('No logs in response');
                            logs.value = [];
                        }
                    } catch (error) {
                        console.error('Error loading logs:', error);
                        logs.value = [];
                        showToast(`Error loading logs: ${error.message}`, 'error');
                    } finally {
                        loadingLogs.value = false;
                    }
                };

                const applyLogFilters = () => {
                    // Reload logs with current filters
                    refreshLogs();
                };

                const formatLogTimestamp = (timestamp) => {
                    return new Date(timestamp).toLocaleString('pt-BR');
                };

                const exportLogs = () => {
                    const logText = filteredLogs.value.map(log => 
                        `[${formatLogTimestamp(log.timestamp)}] ${log.level}: ${log.message}`
                    ).join('\n');
                    const blob = new Blob([logText], { type: 'text/plain' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `vectorizer-logs-${new Date().toISOString()}.log`;
                    a.click();
                    URL.revokeObjectURL(url);
                    showToast('Logs exported', 'success');
                };

                const clearLogs = async () => {
                    if (!confirm('Are you sure you want to clear all logs? This action cannot be undone.')) {
                        return;
                    }
                    try {
                        // Clear logs locally (API doesn't have a DELETE endpoint)
                        logs.value = [];
                        showToast('Logs cleared', 'success');
                    } catch (error) {
                        console.error('Error clearing logs:', error);
                        showToast(`Error clearing logs: ${error.message}`, 'error');
                    }
                };

                // Backups Page Functions
                const loadBackups = async () => {
                    loadingBackups.value = true;
                    try {
                        console.log('Loading backups from API...');
                        const response = await window.apiClient.request('/api/backups');
                        console.log('Backups response:', response);
                        
                        if (response && response.backups) {
                            // Process backups - extract ONLY metadata, discard full data immediately to save memory
                            backups.value = response.backups.map((backup) => {
                                // Immediately discard backup.data to free memory (it's huge!)
                                const hasData = !!backup.data;
                                delete backup.data; // Free memory immediately
                                
                                // Calculate size - if backend didn't provide, estimate based on file size
                                // For large files, estimate based on collections count (very rough)
                                let fileSize = backup.size || 0;
                                
                                // If size is still 0 or very small, estimate (rough approximation)
                                if (fileSize === 0 && hasData) {
                                    // Rough estimate: assume ~5MB per collection (conservative)
                                    fileSize = (backup.collections?.length || 0) * 5 * 1024 * 1024;
                                }
                                
                                // Return ONLY metadata - no data field
                                return {
                                    id: backup.id || backup.name || 'unknown',
                                    name: backup.name || 'Untitled Backup',
                                    date: backup.date || backup.timestamp || new Date().toISOString(),
                                    size: fileSize,
                                    collections: Array.isArray(backup.collections) ? backup.collections : [],
                                    type: backup.type || 'full',
                                };
                            }).filter(backup => backup.id !== 'unknown'); // Filter invalid backups
                            
                            console.log('Loaded', backups.value.length, 'backups (metadata only)');
                        } else {
                            backups.value = [];
                        }
                    } catch (error) {
                        console.error('Error loading backups:', error);
                        backups.value = [];
                        showToast(`Error loading backups: ${error.message}`, 'error');
                    } finally {
                        loadingBackups.value = false;
                    }
                };

                const loadBackupDirectory = async () => {
                    try {
                        console.log('Loading backup directory...');
                        const response = await window.apiClient.request('/api/backups/directory');
                        console.log('Backup directory response:', response);
                        
                        if (response && response.path) {
                            backupDirectory.value = response.path;
                        } else if (response && response.directory) {
                            backupDirectory.value = response.directory;
                        } else {
                            backupDirectory.value = './backups'; // Default
                        }
                    } catch (error) {
                        console.error('Error loading backup directory:', error);
                        backupDirectory.value = './backups'; // Default fallback
                    }
                };

                const createBackup = async () => {
                    // Get backup name from user
                    const defaultName = `backup-${new Date().toISOString().split('T')[0]}-${Date.now()}`;
                    const backupName = prompt('Enter backup name:', defaultName);
                    if (!backupName || !backupName.trim()) {
                        return; // User cancelled or empty name
                    }
                    
                    try {
                        showToast('Creating backup...', 'info');
                        
                        // Get all collection names
                        const collectionNames = collections.value.map(c => c.name);
                        
                        if (collectionNames.length === 0) {
                            showToast('No collections available to backup', 'warning');
                            return;
                        }
                        
                        console.log('Creating backup:', backupName.trim(), 'collections:', collectionNames);
                        const response = await window.apiClient.request('/api/backups/create', {
                            method: 'POST',
                            body: JSON.stringify({
                                name: backupName.trim(),
                                collections: collectionNames
                            })
                        });
                        
                        console.log('Backup create response:', response);
                        showToast(`Backup "${backupName.trim()}" created successfully`, 'success');
                        showCreateBackupModal.value = false;
                        
                        // Reload backups list
                        await loadBackups();
                    } catch (error) {
                        console.error('Error creating backup:', error);
                        showToast(`Error creating backup: ${error.message}`, 'error');
                    }
                };

                const restoreBackup = async (backupId) => {
                    if (!confirm('Are you sure you want to restore this backup? This will overwrite current data.')) {
                        return;
                    }
                    try {
                        showToast('Restoring backup...', 'info');
                        
                        // Get backup to find which collection to restore
                        const backup = backups.value.find(b => b.id === backupId);
                        if (!backup || !backup.collections || backup.collections.length === 0) {
                            throw new Error('Backup has no collections to restore');
                        }
                        
                        console.log('Restoring backup:', backupId);
                        const response = await window.apiClient.request('/api/backups/restore', {
                            method: 'POST',
                            body: JSON.stringify({
                                backup_id: backupId,
                                collection: backup.collections[0] // Restore first collection
                            })
                        });
                        
                        console.log('Backup restore response:', response);
                        showToast('Backup restored successfully', 'success');
                        
                        // Reload data after restore
                        await refreshData();
                        await loadBackups();
                    } catch (error) {
                        console.error('Error restoring backup:', error);
                        showToast(`Error restoring backup: ${error.message}`, 'error');
                    }
                };

                const deleteBackup = async (backupId) => {
                    if (!confirm('Are you sure you want to delete this backup? This action cannot be undone.')) {
                        return;
                    }
                    try {
                        showToast('Deleting backup...', 'info');
                        
                        // The backend doesn't have a DELETE endpoint, so we'll need to delete the file manually
                        // For now, just remove from UI and reload
                        console.log('Deleting backup:', backupId);
                        
                        // Remove from local list
                        backups.value = backups.value.filter(b => b.id !== backupId);
                        showToast('Backup deleted (file deletion not implemented)', 'success');
                        
                        // Reload to sync with server
                        await loadBackups();
                    } catch (error) {
                        console.error('Error deleting backup:', error);
                        showToast(`Error deleting backup: ${error.message}`, 'error');
                    }
                };

                const openBackupDirectory = () => {
                    if (backupDirectory.value) {
                        showToast(`Backup directory: ${backupDirectory.value}`, 'info');
                    } else {
                        showToast('Backup directory not loaded', 'warning');
                    }
                };


                // Watch for indexing progress changes and update collections accordingly
                watch(indexingProgress, (newProgress) => {
                    if (newProgress && newProgress.collections) {
                        // Update the status of collections based on progress
                        collections.value.forEach(collection => {
                            const progressInfo = newProgress.collections.find(c => c.name === collection.name);
                            if (progressInfo) {
                                collection.indexing_status = progressInfo;
                            }
                        });
                    }
                });

                onMounted(async () => {
                    // Test API connection first
                    const connection = await window.apiClient.testConnection();
                    if (!connection.connected) {
                        showToast('API connection failed', 'error');
                        connected.value = false;
                    } else {
                        connected.value = true;
                    }

                    await refreshData();
                    startIndexingRefresh();
                    
                    // Start File Watcher monitoring
                    startFileWatcherMonitoring();

                    // Load initial data for new pages
                    await loadConnections();
                    await loadWorkspaceConfig();
                    await loadBackups();
                    await loadBackupDirectory();

                    // Update connection statuses periodically
                    const connectionStatusInterval = setInterval(async () => {
                        if (connections.value.length > 0) {
                            for (const conn of connections.value) {
                                const status = await testConnectionStatus(conn);
                                if (conn.status !== status) {
                                    conn.status = status;
                                }
                            }
                        }
                    }, 30000); // Check every 30 seconds
                    
                    // Store interval ID for cleanup
                    window.connectionStatusInterval = connectionStatusInterval;
                });

                onBeforeUnmount(() => {
                    stopIndexingRefresh();
                    if (window.connectionStatusInterval) {
                        clearInterval(window.connectionStatusInterval);
                    }
                });

                // Initialize the application
                isInitialized.value = true;

                return {
                    currentPage,
                    collections,
                    collectionsFilter,
                    filteredCollections,
                    indexingProgress,
                    loading,
                    connected,
                    isInitialized,
                    pageTitle,
                    totalVectors,
                    avgDimension,
                    totalMemoryUsed,
                    totalMemory,
                    totalDocuments,
                    systemMemory,
                    setPage,
                    refreshData,
                    formatNumber,
                    formatSize,
                    formatDateTime,
                    formatStatus,
                    getStatusClass,
                    getStatusIcon,
                    getCollectionType,
                    getCollectionProgress,
                    formatLastUpdated,
                    searchQuery,
                    selectedCollection,
                    searchResults,
                    searchPerformed,
                    searchTime,
                    performSearch,
                    selectedVectorCollection,
                    vectors,
                    vectorsLoading,
                    vectorsCurrentPage,
                    vectorsPageSize,
                    vectorsTotal,
                    vectorsTotalPages,
                    loadVectorsList,
                    viewVectorDetails,
                    changeVectorsPage,
                    updateVectorsFilters,
                    executeConsoleRequest,
                    clearConsole,
                    getUptime,
                    truncateText,
                    safeToFixed,
                    getVectorSource,
                    getVectorFileType,
                    getVectorChunkIndex,
                    getVectorDimension,
                    formatVectorPayload,
                    formatVectorEmbedding,
                    showCreateCollectionModal,
                    showCollectionMenu,
                    viewCollectionDetails,
                    browseCollectionVectors,
                    createCollection,
                    deleteCollection,
                    exportCollection,
                    showModal,
                    closeModal,
                    showToast,
                    // File Watcher metrics
                    fileWatcherMetrics,
                    refreshFileWatcherMetrics,
                    formatDuration,
                    getHealthScoreClass,
                    formatBytes,
                    // Graph Relationships Page
                    selectedGraphCollection,
                    graphLoading,
                    graphStats,
                    graphContainer,
                    loadGraphRelationships,
                    // Connections Page
                    connections,
                    showAddConnectionForm,
                    editingConnection,
                    connectionForm,
                    testing,
                    saving,
                    cancelConnectionForm,
                    testConnection,
                    saveConnection,
                    setActiveConnection,
                    editConnection,
                    removeConnection,
                    // Workspace Page
                    workspaceConfig,
                    workspaceSearchFilter,
                    filteredWorkspaceProjects,
                    savingWorkspace,
                    hasUnsavedWorkspaceChanges,
                    expandedCollections,
                    saveWorkspaceConfig,
                    addProject,
                    removeProject,
                    addCollection,
                    removeCollection,
                    toggleCollection,
                    isCollectionExpanded,
                    updateIncludePatterns,
                    updateExcludePatterns,
                    // Config Page
                    activeConfigTab,
                    configTabs,
                    configData,
                    configJsonString,
                    configFormat,
                    configYamlString,
                    configEditorRef,
                    scrollToSection,
                    switchConfigTab,
                    tabToSectionMap,
                    activeConfigTabLabel,
                    activeConfigTabDescription,
                    savingConfig,
                    hasUnsavedConfigChanges,
                    reloadConfig,
                    saveConfig,
                    // Logs Page
                    logs,
                    filteredLogs,
                    loadingLogs,
                    logFilterLevel,
                    logFilterSearch,
                    logMaxLines,
                    logAutoScroll,
                    logShowTimestamps,
                    logsContainer,
                    refreshLogs,
                    applyLogFilters,
                    formatLogTimestamp,
                    exportLogs,
                    clearLogs,
                    // Backups Page
                    backups,
                    loadingBackups,
                    backupDirectory,
                    showCreateBackupModal,
                    createBackup,
                    restoreBackup,
                    deleteBackup,
                    openBackupDirectory
                };
            }
        }).mount('#app');
    </script>
</body>
</html>