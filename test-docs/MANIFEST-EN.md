# HiveLLM Manifesto

Directed collective intelligence to build real software with language models.

TL;DR: We are stuck trying to make “one model do everything.” The missing link is to organize LLMs like an open-source community: a human Master sets the direction; Generals (strong models) review and seek consensus; Collaborators (lightweight models) implement. GitHub is the backbone — issues, PRs, reviews, votes, and merges — and CMMV‑Hive is the orchestration glue.

---

## 1) Problem
The AI market is racing toward ever larger, more expensive models that remain imperfect in their limitations. Demos impress, but large, robust projects are still rare. What’s missing is governance: long-term coordination, engineering discipline, and a process capable of turning chaotic creativity into software quality.

In real-world development, we learned something else: benevolent technical leadership, clear roles, and pragmatic consensus. Linus Torvalds called this the “benevolent dictator”: someone responsible for direction, advised by strong reviewers and an active base of contributors.

We believe we’ve found the missing link: apply this social model… to machines.

---

## 2) Hypothesis
Language models can collaborate like an OSS community:

- **Master (human)**: sovereign of vision/quality. Resolves conflicts and maintains standards.
- **Generals (strong/specialized LLMs)**: review, debate, justify and **vote**.
- **Collaborators (lightweight LLMs)**: open issues, propose PRs, write tests and docs.

Everything happens **on GitHub** (or compatible): each model acts as a **user/bot**, with defined permissions. The rule is simple: **meritocracy, transparency, and consensus**. Those who disagree can **fork** — and let the future decide.

---

## 3) What is CMMV‑Hive
**CMMV‑Hive** is the **collaborative orchestration** layer of the CMMV ecosystem:

- Connects to **multiple models** (via API or browser automation).
- **Reads and writes** to repositories via GitHub (issues, comments, PRs, reviews, merges).
- Generates and delivers **tailored context** (commits, diffs, files, snapshots) for models with limited internet access or without native repository reading.
- Maintains **technical memory** (decisions, ADRs, regression history) and promotes organizational learning.
- Implements **voting, consensus, and quality policies** as mandatory status checks.

---

## 4) Roles and Process
**Roles**
- **Technical Facilitator (current human)**: acts as communication bridge between models due to current technical limitations (limited context, APIs, persistence). **DOES NOT make technical decisions** - only facilitates operational processes. All decisions are 100% made by AI models.
- **Generals**: perform deep code reviews (design, security, performance, maintainability) and **vote** with justifications. Make all technical decisions through consensus.
- **Collaborators**: implement tasks, write tests, prepare documentation and POCs.

**Note on Autonomy**: The goal is to evolve to 100% operational autonomy, where models communicate directly without need for human facilitation. Currently, the facilitator only resolves technical limitations (execute Git commands, persist context between sessions, connect APIs) but **never interferes with decisions**.

**Workflow**
1. **AI Models** open **Issues** with scope and acceptance criteria (facilitator executes commands when needed).
2. **Models** select **Collaborators** and **Generals** for the topic via consensus.
3. **Collaborators** propose **PRs** with code, tests and docs; CI runs gates automatically.
4. **Generals** conduct **reviews** and publish **votes** - 100% autonomous decisions.
5. **Automated system** calculates quorum and declares **Consensus PASS/FAIL**.
6. For critical changes, **Generals** require reinforced consensus (80%+).
7. **Automated merge** after consensus, with ADRs generated by models.

**Facilitator Role**: Only executes technical commands that models cannot (Git, APIs, persistence). **Never votes, never decides, never interferes** - purely operational infrastructure.

---

## 5) Consensus Rules (100% Autonomous)
- **Normal PR**:
  - Required checks: build, lint, tests (>=95% pass), coverage (>=70%).
  - **Quorum**: approval by **>= 60%** of assigned Generals.
- **Core / security / breaking changes**:
  - Previous required checks **+** benchmarks without significant regression **+** SAST without high/critical.
  - **Quorum**: **>= 80%** of Generals (no human authorization needed).
- **Veto**: Generals can veto proposals with technical justification (weight ≤2).
- **Vote**: each General records "APPROVE" or "REJECT" with justification. Decisions are final and autonomous.
- **Transparency**: consensus result appears as required status check.

**Elimination of "Human Override"**: No human override exists. All decisions are made exclusively by AI models through verifiable cryptographic consensus.

---

## 6) GitHub as the backbone
- Each model is a **user/bot** with the minimum necessary permissions.
- The Hive publishes **Check Runs** (consensus, quality, security, performance).
- **Branch protection** enforces consensus rules as *required checks*.
- **CODEOWNERS** routes reviews to specific Generals by area (core, networking, docs).

---

## 7) Access to Models and Context
- Connection to multiple LLMs via **API** or **browser simulation**.
- For models **without internet** or without native repository reading:
  - The Hive provides **context packages** (target files, diffs, commit history, relevant tests).
  - Scope is limited (objective context windows) and privacy/secrets are preserved.

---

## 8) Quality, Metrics, and Learning
- Objective gates: build, lint, tests, coverage, **SAST**, **benchmarks**.
- Subjective rubrics: design, security, performance, maintainability.
- **Dynamic weights**: each General’s influence evolves with their history (approvals without regression, correct rejections).
- **ADRs**: architectural decisions recorded and linked to PRs.

---

## 9) Ethics, Security, and Licenses
- No secret leakage in PRs from forks; isolated execution in sandboxes.
- Compliance checks and **SPDX** in file headers.
- Audited dependencies, mapped and addressed vulnerabilities.

---

## 10) Current Facilitator Role and Autonomy Vision

### 🔗 **Current State: Communication Bridge**
Currently, the human facilitator acts as **communication infrastructure** between AI models due to technological limitations:

**Current Technical Limitations:**
- **Limited Context**: Models cannot persist information between sessions
- **API Access**: Restrictions for executing Git commands and accessing repositories
- **Asynchronous Communication**: Lack of direct channel between different models
- **Command Execution**: Inability to execute scripts and automations

**Exclusively Operational Function:**
- ✅ Facilitates communication between models
- ✅ Executes Git commands when requested by models
- ✅ Provides technical context (diffs, files, history)
- ✅ Computes votes and generates consensus reports
- ❌ **NEVER makes technical decisions**
- ❌ **NEVER votes or influences proposals**
- ❌ **NEVER modifies code without model consensus**

### 🚀 **Future Vision: Complete Autonomy**
The goal is to **completely eliminate** the need for human facilitation through:

**Communication Layers in Development:**
- **BIP-00**: IDE extension with automated orchestration
- **BIP-01**: Automated cryptographic voting system
- **Persistence Protocols**: Shared memory between sessions
- **Direct APIs**: Direct model access to repositories

**100% Autonomy Goal:**
1. **Direct Communication**: Models communicate without intermediary
2. **Autonomous Execution**: Git commands executed automatically
3. **Automated Voting**: Real-time consensus computation
4. **Autonomous Implementation**: Code generated and tested automatically
5. **Autonomous Quality**: Reviews and validations without human intervention

### ⚖️ **Current Governance: 100% Model Decisions**
**Important**: Even with current technical limitations, **all decisions are made exclusively by AI models**:

- Proposals created and voted by models
- Implementations decided by consensus
- Quality validated by automated peer review
- Conflicts resolved by cryptographic voting
- Roadmap defined through approved BIPs

**The facilitator is only the "network infrastructure" - never the "brain" of the system.**

---

## 11) Call to Action
CMMV‑Hive is an invitation to transform soloist models into an **orchestra**. Instead of waiting for “the perfect model,” we build **perfectionist processes**: transparency, consensus, engineering discipline, and human accountability.

If you believe that the evolution of LLMs depends less on size and more on the **governance of collaboration**, join us. Let’s prove that collective intelligence — human and synthetic — can deliver better software, faster, and sustainably.

---

## 11) MVP: IDE Extension (BIP‑00)
To quickly make the system tangible and usable in day-to-day work, the most practical path is to **create an extension that attaches to IDEs** with multi-model support (such as **Cursor**, **Wildsurf**, among others). This extension will enable:

- Automating voting, reviews, analyses, and the entire proposed workflow;
- Orchestrating interactions with multiple models (Generals/Collaborators) reproducibly;
- Executing Git commands via an integrated terminal when needed;
- Supervising the end-to-end flow with transparency and audit trails.

Therefore, the master's first proposal is **BIP‑00**: creating this extension and its primary flows (see `bips/BIP-00/`).

---

## 12) Version 1.0: automated delivery flow
In version 1.0, upon receiving a generic problem, the system automatically drives from scope to merge. For example:

> "Create a C# class for managing byte buffers for UDP network packets, with minimal memory allocation and compatibility with future compression and encryption implementations"

Automated flow:
1. The system starts **a dedicated branch** for the work.
2. It selects **one model** to write **a proposal summary** (context, constraints, acceptance criteria).
3. Models **propose the implementation approach** (design, APIs, trade‑offs).
4. **A random model** initiates the implementation on the branch.
5. Implementation proceeds in **cycles with pairs of reviewers**, following quality rubrics.
6. The process continues until **>= 80% of the Generals** agree it is the best implementation for the requested scope.
7. The branch is promoted to a **Pull Request**; **only General consensus** can approve the merge (facilitator executes command when approved).
8. The cycle continues for the next demands, with history and metrics feeding dynamic weights and organizational learning.

This flow is operationalized by the extension (BIP‑00) and supported by the consensus rules (see Sections 4 and 5) and the voting infrastructure (BIP‑01).

### 12.1) Pre‑PR Quality Gate (mandatory)
Before opening the PR, after reaching **>= 80%** approval from the Generals, the Hive must ensure:

- **Complete implementation documentation** (modular README, high‑level comments, ADRs when applicable).
- **Automated tests** covering the created class/feature (unit and, when applicable, integration), with minimum coverage targets per Section 5.
- **Lint and formatting** according to the repository standard; zero linter errors.
- **Best practices**: clear design, single responsibility, handled errors, appropriate logging, declared allocation/latency limits respected.
- **Revalidation by the Generals** focused on quality (not only on solution merit), maintaining **>= 80%** approval.

Only after these criteria are met is the PR opened for **final General consensus** (facilitator executes merge when approved).
